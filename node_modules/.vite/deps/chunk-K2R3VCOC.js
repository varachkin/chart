import {
  Action,
  Getter,
  Plugin,
  PluginHost,
  Sizer,
  Template,
  TemplateConnector,
  TemplatePlaceholder,
  clear,
  createStateHelper,
  hasWindow,
  withComponents
} from "./chunk-OSUPB7U7.js";
import {
  band,
  linear
} from "./chunk-J4QZ547B.js";
import {
  extent_default
} from "./chunk-J3FD4ZJL.js";
import {
  require_react
} from "./chunk-LL6ON2IQ.js";
import {
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/@devexpress/dx-react-chart/dist/dx-react-chart.es.js
var import_react = __toESM(require_react());

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi2 : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon2)
    return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path_default();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon2))
      context.moveTo(0, 0);
    else if (da > tau2 - epsilon2) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon2) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
      if (rp > epsilon2) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon2)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon2)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi2 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon2))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon2) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc1 < rc)
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon2) || !(da0 > epsilon2))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon2) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
        if (rc0 < rc)
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };
  return arc;
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default() {
  var x2 = x, y2 = y, defined = constant_default(true), context = null, curve = linear_default, output = null;
  function line(data) {
    var i, n = data.length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default() {
  var x0 = x, x1 = null, y0 = constant_default(0), y1 = y, defined = constant_default(true), context = null, curve = linear_default, output = null;
  function area(data) {
    var i, j, k2, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default(d) {
  return d;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value = identity_default, sortValues = descending_default, sort = null, startAngle = constant_default(0), endAngle = constant_default(tau2), padAngle = constant_default(0);
  function pie(data) {
    var i, n = data.length, j, k2, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau2, Math.max(-tau2, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort != null)
      index.sort(function(i2, j2) {
        return sort(data[i2], data[j2]);
      });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), pie) : value;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi2);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau2);
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = Math.sin(pi2 / 10) / Math.sin(7 * pi2 / 10);
var kx = Math.sin(tau2 / 10) * kr;
var ky = -Math.cos(tau2 / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/symbol.js
function symbol_default() {
  var type = constant_default(circle_default), size = constant_default(64), context = null;
  function symbol() {
    var buffer;
    if (!context)
      context = buffer = path_default();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant_default(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x0 = x2[0], y0 = y2[0], dx = x2[j] - x0, dy = y2[j] - y0, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point4(that, t0, t1) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t1 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
        break;
      default:
        point4(this, this._t0, t1 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t1;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};

// node_modules/d3-shape/src/offset/none.js
function none_default(series2, order) {
  if (!((n = series2.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series2[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series2[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series2) {
  var n = series2.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
  return d[key];
}
function stack_default() {
  var keys = constant_default([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }
    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default(slice.call(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default(slice.call(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series2, order) {
  if (!((n = series2.length) > 0))
    return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series2[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series2[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

// node_modules/@devexpress/dx-chart-core/dist/dx-chart-core.es.js
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
      t[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t[p[i]] = s2[p[i]];
    }
  return t;
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || from);
}
var TOP = "top";
var BOTTOM = "bottom";
var LEFT = "left";
var RIGHT = "right";
var MIDDLE = "middle";
var END = "end";
var START = "start";
var ARGUMENT_DOMAIN = "argument-domain";
var VALUE_DOMAIN = "value-domain";
var HOVERED = "hovered";
var SELECTED = "selected";
var DIFFERENCE = 3;
var scaleLinear = linear;
var scaleBand = function() {
  return band().paddingInner(0.3).paddingOuter(0.15);
};
var isHorizontal = function(name, rotated) {
  return name === ARGUMENT_DOMAIN === !rotated;
};
var makeScaleHelper = function(linear2, band2) {
  var func = function(scale) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var choosen = "bandwidth" in scale ? band2 : linear2;
    return choosen.apply(void 0, __spreadArray([scale], __read(args), false));
  };
  return func;
};
var getLinearScaleWidth = function(_) {
  return 0;
};
var getBandScaleWidth = function(scale) {
  return scale.bandwidth();
};
var getWidth = makeScaleHelper(getLinearScaleWidth, getBandScaleWidth);
var getValueDomainName = function(name) {
  return name || VALUE_DOMAIN;
};
var floatsEqual = function(a2, b) {
  return Math.abs(a2 - b) < Number.EPSILON;
};
var rangesEqual = function(r1, r2) {
  return floatsEqual(r1[0], r2[0]) && floatsEqual(r1[1], r2[1]);
};
var wrapLinearScale = function(scale) {
  return scale;
};
var wrapBandScale = function(scale) {
  var ret = function(value) {
    return scale(value) + scale.bandwidth() / 2;
  };
  Object.assign(ret, scale);
  return ret;
};
var wrapScale = makeScaleHelper(wrapLinearScale, wrapBandScale);
var makeScale = function(_a3, range) {
  var factory = _a3.factory, domain = _a3.domain;
  var scale = (factory || scaleLinear)().domain(domain).range(range);
  return wrapScale(scale);
};
var scaleLinearBounds = function(scale, bounds) {
  return bounds.map(scale);
};
var scaleBandBounds = function(scale, bounds) {
  var cleanScale = scale.copy().paddingInner(0).paddingOuter(0);
  var fullRange = scale.range();
  var sign2 = Math.sign(fullRange[1] - fullRange[0]);
  return sign2 >= 0 ? [cleanScale(bounds[0]), cleanScale(bounds[1]) + cleanScale.bandwidth()] : [cleanScale(bounds[0]) + cleanScale.bandwidth(), cleanScale(bounds[1])];
};
var moveLinearScaleBounds = function(scale, bounds, delta) {
  var fullRange = scale.range();
  var sign2 = Math.sign(fullRange[1] - fullRange[0]);
  var range = scaleLinearBounds(scale, bounds);
  var r0 = range[0] + delta;
  var r1 = range[1] + delta;
  if (Math.sign(r0 - fullRange[0]) !== sign2) {
    r0 = fullRange[0];
    r1 = r0 + range[1] - range[0];
  }
  if (Math.sign(fullRange[1] - r1) !== sign2) {
    r1 = fullRange[1];
    r0 = r1 - range[1] + range[0];
  }
  var newBounds = [scale.invert(r0), scale.invert(r1)];
  return rangesEqual(bounds, newBounds) ? bounds : newBounds;
};
var adjustBandScaleMoveStep = function(delta, step) {
  var ratio = Math.abs(delta / step);
  var sign2 = Math.sign(delta / step);
  if (ratio >= 0.5) {
    return sign2 * Math.round(ratio);
  }
  if (ratio >= 0.3) {
    return sign2;
  }
  if (Math.abs(delta) > 30) {
    return sign2;
  }
  return 0;
};
var moveBandScaleBounds = function(scale, bounds, delta) {
  var domain = scale.domain();
  var fullRange = scale.range();
  var step = (fullRange[1] - fullRange[0]) / domain.length;
  var rangeStep = adjustBandScaleMoveStep(delta, step);
  if (rangeStep === 0) {
    return bounds;
  }
  var range = scaleBounds(scale, bounds);
  var range0 = Math.round((range[0] - fullRange[0]) / step);
  var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;
  var new0 = range0 + rangeStep;
  var new1 = range1 + rangeStep;
  if (new0 < 0) {
    new0 = 0;
    new1 = new0 + range1 - range0;
  }
  if (new1 > domain.length - 1) {
    new1 = domain.length - 1;
    new0 = new1 - range1 + range0;
  }
  if (new0 === range0 || new1 === range1) {
    return bounds;
  }
  return [domain[new0], domain[new1]];
};
var LINEAR_SCALE_ZOOMING_THRESHOLD = 1e3;
var growLinearScaleBounds = function(scale, bounds, delta, anchor) {
  var fullRange = scale.range();
  var minRangeThreshold = (fullRange[1] - fullRange[0]) / LINEAR_SCALE_ZOOMING_THRESHOLD;
  var sign2 = Math.sign(fullRange[1] - fullRange[0]);
  var range = scaleBounds(scale, bounds);
  if (delta > 0 && Math.abs(range[1] - range[0]) <= Math.abs(minRangeThreshold)) {
    return bounds;
  }
  if (delta < 0 && Math.abs(range[1] - range[0]) >= Math.abs(fullRange[1] - fullRange[0])) {
    return bounds;
  }
  var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));
  var r0 = range[0] + sign2 * delta * 2 * t;
  var r1 = range[1] - sign2 * delta * 2 * (1 - t);
  if (Math.sign(r0 - fullRange[0]) !== sign2) {
    r0 = fullRange[0];
  }
  if (Math.sign(fullRange[1] - r1) !== sign2) {
    r1 = fullRange[1];
  }
  if (Math.sign(r1 - r0) !== sign2 || Math.abs(r1 - r0) < Math.abs(minRangeThreshold)) {
    if (Math.abs(r0 - range[0]) < Math.abs(minRangeThreshold / 2)) {
      r0 = range[0];
      r1 = r0 + minRangeThreshold;
    } else if (Math.abs(r1 - range[1]) < Math.abs(minRangeThreshold / 2)) {
      r1 = range[1];
      r0 = r1 - minRangeThreshold;
    } else {
      r0 = anchor - minRangeThreshold / 2;
      r1 = anchor + minRangeThreshold / 2;
    }
  }
  var newBounds = [scale.invert(r0), scale.invert(r1)];
  return rangesEqual(bounds, newBounds) ? bounds : newBounds;
};
var growBandScaleBounds = function(scale, bounds, delta, anchor) {
  var domain = scale.domain();
  var fullRange = scale.range();
  var step = (fullRange[1] - fullRange[0]) / domain.length;
  var range = scaleBounds(scale, bounds);
  var range0 = Math.round((range[0] - fullRange[0]) / step);
  var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;
  var rangeStep = Math.sign(delta);
  if (rangeStep === 0 || rangeStep > 0 && range0 === range1 || rangeStep < 0 && range0 === 0 && range1 === domain.length - 1) {
    return bounds;
  }
  var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));
  var new0 = range0 + Math.round(rangeStep * 2 * t);
  var new1 = range1 - Math.round(rangeStep * 2 * (1 - t));
  if (new0 < 0) {
    new0 = 0;
  }
  if (new1 > domain.length - 1) {
    new1 = domain.length - 1;
  }
  if (new0 > new1) {
    if (t <= 0.5) {
      new1 = new0;
    } else {
      new0 = new1;
    }
  }
  if (new0 === range0 && new1 === range1) {
    return bounds;
  }
  return [domain[new0], domain[new1]];
};
var invertLinearScaleBounds = function(scale, range) {
  var fullRange = scale.range();
  var match = Math.sign(fullRange[1] - fullRange[0]) === Math.sign(range[1] - range[0]);
  return [
    scale.invert(range[match ? 0 : 1]),
    scale.invert(range[match ? 1 : 0])
  ];
};
var matchPointToBand = function(domain, range, p) {
  var i = Math.floor(domain.length * (p - range[0]) / (range[1] - range[0]));
  return domain[Math.min(i, domain.length - 1)];
};
var invertBandScaleBounds = function(scale, range) {
  var domain = scale.domain();
  var fullRange = scale.range();
  return [
    matchPointToBand(domain, fullRange, range[0]),
    matchPointToBand(domain, fullRange, range[1])
  ];
};
var scaleBounds = makeScaleHelper(scaleLinearBounds, scaleBandBounds);
var moveBounds = makeScaleHelper(moveLinearScaleBounds, moveBandScaleBounds);
var growBounds = makeScaleHelper(growLinearScaleBounds, growBandScaleBounds);
var invertBoundsRange = makeScaleHelper(invertLinearScaleBounds, invertBandScaleBounds);
var _a;
var makeDomain = function(_a3) {
  var factory = _a3.factory, modifyDomain = _a3.modifyDomain;
  return {
    domain: [],
    factory,
    isDiscrete: !!(factory && isDiscrete(factory)),
    modifyDomain
  };
};
var defaultDomains = (_a = {}, _a[ARGUMENT_DOMAIN] = makeDomain({}), _a[VALUE_DOMAIN] = makeDomain({}), _a);
var addDomain = function(domains, name, options) {
  var _a3;
  return __assign(__assign({}, domains), (_a3 = {}, _a3[name] = makeDomain(options), _a3));
};
var mergeContinuousDomains = function(domain, items) {
  var newDomain = extent_default(__spreadArray(__spreadArray([], __read(domain), false), __read(items), false));
  return rangesEqual(newDomain, domain) ? domain : newDomain;
};
var mergeDiscreteDomains = function(domain, items) {
  var newDomain = Array.from(new Set(__spreadArray(__spreadArray([], __read(domain), false), __read(items), false)));
  return newDomain.length === domain.length ? domain : newDomain;
};
var getArgument = function(point5) {
  return point5.argument;
};
var getValue = function(point5) {
  return point5.value;
};
var guessFactory = function(points, getItem) {
  return points.length && typeof getItem(points[0]) === "string" ? scaleBand : scaleLinear;
};
var isDiscrete = function(factory) {
  return "bandwidth" in factory();
};
var updateDomainFactory = function(domain, series2, getItem) {
  if (domain.factory) {
    return domain;
  }
  var factory = guessFactory(series2.points, getItem);
  return __assign(__assign({}, domain), { factory, isDiscrete: isDiscrete(factory) });
};
var updateDomainItems = function(domain, items) {
  var merge = domain.isDiscrete ? mergeDiscreteDomains : mergeContinuousDomains;
  var merged = merge(domain.domain, items);
  return merged === domain.domain ? domain : __assign(__assign({}, domain), { domain: domain.modifyDomain ? domain.modifyDomain(merged) : merged });
};
var getArgumentDomainItems = function(series2) {
  return series2.points.map(getArgument);
};
var getValueDomainItems = function(series2) {
  var items = series2.points.map(getValue);
  return series2.getPointTransformer.isStartedFromZero ? __spreadArray([0], __read(items), false) : items;
};
var updateDomain = function(domain, series2, getItem, getDomainItems) {
  return updateDomainItems(updateDomainFactory(domain, series2, getItem), getDomainItems(series2));
};
var extendDomains = function(domains, series2) {
  var argumentDomain = updateDomain(domains[ARGUMENT_DOMAIN], series2, getArgument, getArgumentDomainItems);
  var valueDomainName = getValueDomainName(series2.scaleName);
  var valueDomain = updateDomain(domains[valueDomainName], series2, getValue, getValueDomainItems);
  var changes = {};
  if (argumentDomain !== domains[ARGUMENT_DOMAIN]) {
    changes[ARGUMENT_DOMAIN] = argumentDomain;
  }
  if (valueDomain !== domains[valueDomainName]) {
    changes[valueDomainName] = valueDomain;
  }
  return Object.keys(changes).length ? __assign(__assign({}, domains), changes) : domains;
};
var buildScales = function(domains, ranges) {
  var scales = {};
  Object.keys(domains).forEach(function(name) {
    scales[name] = makeScale(domains[name], ranges[name === ARGUMENT_DOMAIN ? ARGUMENT_DOMAIN : VALUE_DOMAIN]);
  });
  return scales;
};
var isEqual = function(_a3, _b2) {
  var firstWidth = _a3.width, firstHeight = _a3.height;
  var secondWidth = _b2.width, secondHeight = _b2.height;
  return firstWidth === secondWidth && firstHeight === secondHeight;
};
var bBoxes = function(prevBBoxes, _a3) {
  var _b2;
  var bBox = _a3.bBox, placeholder = _a3.placeholder;
  if (isEqual(prevBBoxes[placeholder] || {}, bBox))
    return prevBBoxes;
  return __assign(__assign({}, prevBBoxes), (_b2 = {}, _b2[placeholder] = bBox, _b2));
};
var getRanges = function(paneSize, rotated) {
  var _a3;
  var horRange = [0, paneSize.width];
  var verRange = [paneSize.height, 0];
  return _a3 = {}, _a3[ARGUMENT_DOMAIN] = rotated ? verRange : horRange, _a3[VALUE_DOMAIN] = rotated ? horRange : verRange, _a3;
};
var _a$1;
var _b;
var getTicks = function(scale, count) {
  return scale.ticks ? scale.ticks(count) : scale.domain();
};
var createTicks = function(scale, count, callback) {
  return getTicks(scale, count).map(function(tick, index) {
    return callback(scale(tick), String(index), tick);
  });
};
var getFormat = function(scale, count, tickFormat) {
  if (scale.tickFormat) {
    return tickFormat ? tickFormat(scale, count) : scale.tickFormat(count);
  }
  return function(tick) {
    return tick;
  };
};
var rotatedPositions = (_a$1 = {}, _a$1[LEFT] = BOTTOM, _a$1[RIGHT] = TOP, _a$1[BOTTOM] = LEFT, _a$1[TOP] = RIGHT, _a$1);
var positionFlags = (_b = {}, _b[LEFT] = false, _b[RIGHT] = false, _b[BOTTOM] = true, _b[TOP] = true, _b);
var getRotatedPosition = function(position) {
  return rotatedPositions[position];
};
var isValidPosition = function(position, scaleName, rotated) {
  return positionFlags[position] === isHorizontal(scaleName, rotated);
};
var createHorizontalOptions = function(position, tickSize, indentFromAxis) {
  var isStart = position === BOTTOM;
  return {
    y1: 0,
    y2: isStart ? +tickSize : -tickSize,
    yText: isStart ? +indentFromAxis : -indentFromAxis,
    dy: isStart ? "1em" : "0em",
    textAnchor: MIDDLE
  };
};
var createVerticalOptions = function(position, tickSize, indentFromAxis) {
  var isStart = position === LEFT;
  return {
    x1: 0,
    x2: isStart ? -tickSize : +tickSize,
    xText: isStart ? -indentFromAxis : +indentFromAxis,
    dy: "0.3em",
    textAnchor: isStart ? END : START
  };
};
var DEFAULT_TICK_COUNT = 10;
var getTickCount = function(scaleRange, paneSize) {
  var rangeToPaneRatio = Math.abs(scaleRange[0] - scaleRange[1]) / paneSize;
  return Math.round(DEFAULT_TICK_COUNT * (isFinite(rangeToPaneRatio) ? rangeToPaneRatio : 1));
};
var createTickFilter = function(isHor, size) {
  return isHor ? function(tick) {
    return tick.x1 >= 0 && tick.x1 <= size;
  } : function(tick) {
    return tick.y1 >= 0 && tick.y1 <= size;
  };
};
var tickCoordinatesGetter = function(_a3) {
  var isHor = _a3.isHor, scale = _a3.scale, tickCount = _a3.tickCount, tickFormat = _a3.tickFormat, position = _a3.position, tickSize = _a3.tickSize, indentFromAxis = _a3.indentFromAxis;
  var formatTick = getFormat(scale, tickCount, tickFormat);
  var options = (isHor ? createHorizontalOptions : createVerticalOptions)(position, tickSize, indentFromAxis);
  return function(coordinates, key, tick) {
    return __assign({ key, x1: coordinates, x2: coordinates, y1: coordinates, y2: coordinates, xText: coordinates, yText: coordinates, text: formatTick(tick) }, options);
  };
};
var gridCoordinatesGetter = function(_a3) {
  var isHor = _a3.isHor;
  var options = isHor ? { y1: 0 } : { x1: 0 };
  return function(coordinates, key) {
    return __assign({ key, x1: coordinates, y1: coordinates }, options);
  };
};
var getTickCoordinates = function(_a3) {
  var scaleName = _a3.scaleName, scale = _a3.scale, paneSize = _a3.paneSize, rotated = _a3.rotated, callback = _a3.callback, restProps = __rest(_a3, ["scaleName", "scale", "paneSize", "rotated", "callback"]);
  var isHor = isHorizontal(scaleName, rotated);
  var tickCount = getTickCount(scale.range(), paneSize[1 - Number(isHor)]);
  var ticks = createTicks(scale, tickCount, callback(__assign({ isHor, scale, tickCount }, restProps)));
  var visibleTicks = ticks.filter(createTickFilter(isHor, paneSize[1 - Number(isHor)]));
  return {
    ticks: visibleTicks,
    sides: [Number(isHor), Number(!isHor)]
  };
};
var getArg = function(_a3) {
  var arg = _a3.arg;
  return arg;
};
var getVal = function(_a3) {
  var val = _a3.val;
  return val;
};
var getStartVal = function(_a3) {
  var startVal = _a3.startVal;
  return startVal;
};
var dArea = area_default().x(getArg).y1(getVal).y0(getStartVal);
var dRotateArea = area_default().x1(getStartVal).x0(getVal).y(getArg);
var dLine = line_default().x(getArg).y(getVal);
var dRotateLine = line_default().x(getVal).y(getArg);
var dSpline = line_default().x(getArg).y(getVal).curve(monotoneX);
var dRotateSpline = line_default().x(getVal).y(getArg).curve(monotoneY);
var dBar = function(arg, val, startVal, width, rotated) {
  var height = Math.abs(val - startVal);
  var minVal = Math.min(val, startVal);
  return {
    x: rotated ? minVal : arg - width / 2,
    y: rotated ? arg - width / 2 : minVal,
    width: rotated ? height : width || 2,
    height: rotated ? width || 2 : height
  };
};
var getPiePointTransformer = function(_a3) {
  var argumentScale = _a3.argumentScale, valueScale = _a3.valueScale, points = _a3.points;
  var x2 = Math.max.apply(Math, __spreadArray([], __read(argumentScale.range()), false)) / 2;
  var y2 = Math.max.apply(Math, __spreadArray([], __read(valueScale.range()), false)) / 2;
  var maxRadius = Math.min(x2, y2);
  var pieData = pie_default().sort(null).value(function(d) {
    return d.value;
  })(points);
  return function(point5) {
    var _a4 = pieData[point5.index], startAngle = _a4.startAngle, endAngle = _a4.endAngle;
    return __assign(__assign({}, point5), { arg: x2, val: y2, startAngle, endAngle, maxRadius });
  };
};
var getLinePointTransformer = function(_a3) {
  var argumentScale = _a3.argumentScale, valueScale = _a3.valueScale;
  return function(point5) {
    return __assign(__assign({}, point5), { arg: argumentScale(point5.argument), val: valueScale(point5.value) });
  };
};
var getScatterPointTransformer = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return getLinePointTransformer.apply(void 0, __spreadArray([], __read(args), false));
};
var getAreaPointTransformer = function(series2) {
  var transform = getLinePointTransformer(series2);
  var startVal = series2.valueScale(0);
  return function(point5) {
    var ret = transform(point5);
    return __assign(__assign({}, ret), { startVal });
  };
};
getAreaPointTransformer.isStartedFromZero = true;
var getBarPointTransformer = function(_a3) {
  var argumentScale = _a3.argumentScale, valueScale = _a3.valueScale;
  var startVal = valueScale(0);
  return function(point5) {
    return __assign(__assign({}, point5), { arg: argumentScale(point5.argument), val: valueScale(point5.value), startVal, maxBarWidth: getWidth(argumentScale) });
  };
};
getBarPointTransformer.isStartedFromZero = true;
getBarPointTransformer.isBroad = true;
getPiePointTransformer.getPointColor = function(palette, index) {
  return palette[index % palette.length];
};
var findSeriesByName = function(name, series2) {
  return series2.find(function(seriesItem) {
    return seriesItem.symbolName === name;
  });
};
var dSymbol = function(_a3) {
  var size = _a3.size;
  return symbol_default().size(Math.pow(size, 2)).type(circle_default)();
};
var dPie = function(maxRadius, innerRadius, outerRadius, startAngle, endAngle) {
  return arc_default()({
    startAngle,
    endAngle,
    innerRadius: innerRadius * maxRadius,
    outerRadius: outerRadius * maxRadius
  });
};
var getRect = function(cArg, cVal, dArg, dVal, rotated) {
  var minArg = cArg - dArg;
  var minVal = cVal - dVal;
  var maxArg = cArg + dArg;
  var maxVal = cVal + dVal;
  return rotated ? [minVal, minArg, maxVal, maxArg] : [minArg, minVal, maxArg, maxVal];
};
getBarPointTransformer.getTargetElement = function(point5) {
  var _a3 = point5, arg = _a3.arg, val = _a3.val, startVal = _a3.startVal, barWidth = _a3.barWidth, maxBarWidth = _a3.maxBarWidth, rotated = _a3.rotated;
  var halfWidth = barWidth * maxBarWidth / 2;
  var halfHeight = Math.abs(startVal - val) / 2;
  var centerVal = (val + startVal) / 2;
  return getRect(arg, centerVal, halfWidth, halfHeight, rotated);
};
getPiePointTransformer.getTargetElement = function(point5) {
  var _a3 = point5, x2 = _a3.arg, y2 = _a3.val, innerRadius = _a3.innerRadius, outerRadius = _a3.outerRadius, maxRadius = _a3.maxRadius, startAngle = _a3.startAngle, endAngle = _a3.endAngle;
  var center = arc_default().centroid({
    startAngle,
    endAngle,
    innerRadius: innerRadius * maxRadius,
    outerRadius: outerRadius * maxRadius
  });
  var cx = center[0] + x2;
  var cy = center[1] + y2;
  return getRect(cx, cy, 0.5, 0.5, false);
};
getAreaPointTransformer.getTargetElement = function(_a3) {
  var arg = _a3.arg, val = _a3.val, rotated = _a3.rotated;
  return getRect(arg, val, 1, 1, rotated);
};
getLinePointTransformer.getTargetElement = getAreaPointTransformer.getTargetElement;
getScatterPointTransformer.getTargetElement = function(obj) {
  var _a3 = obj, arg = _a3.arg, val = _a3.val, point5 = _a3.point, rotated = _a3.rotated;
  var t = point5.size / 2;
  return getRect(arg, val, t, t, rotated);
};
var getUniqueName = function(list, name) {
  var names = new Set(list.map(function(item) {
    return item.name;
  }));
  var ret = name;
  while (names.has(ret)) {
    ret = ret.replace(/\d*$/, function(str) {
      return str ? +str + 1 : 0;
    });
  }
  return ret;
};
var createPoints = function(_a3, data, props, palette) {
  var argumentField = _a3.argumentField, valueField = _a3.valueField, getPointTransformer = _a3.getPointTransformer;
  var points = [];
  data.forEach(function(dataItem, index) {
    var argument = dataItem[argumentField];
    var value = dataItem[valueField];
    if (argument !== void 0 && value !== void 0) {
      points.push(__assign(__assign({ argument, value, index }, props), { color: getPointTransformer.getPointColor ? getPointTransformer.getPointColor(palette, index) : props.color }));
    }
  });
  return points;
};
var addSeries = function(series2, data, palette, props, restProps) {
  var index = series2.length;
  var seriesColor = props.color || palette[index % palette.length];
  return __spreadArray(__spreadArray([], __read(series2), false), [__assign(__assign({}, props), { index, name: getUniqueName(series2, props.name), points: createPoints(props, data, __assign(__assign({}, restProps), { color: seriesColor }), palette), color: seriesColor })], false);
};
var scalePoints = function(series2, scales, rotated) {
  var transform = series2.getPointTransformer(__assign(__assign({}, series2), { argumentScale: scales[ARGUMENT_DOMAIN], valueScale: scales[getValueDomainName(series2.scaleName)] }));
  var ret = __assign(__assign({}, series2), { rotated, points: series2.points.map(function(point5) {
    return __assign(__assign({}, transform(point5)), { rotated });
  }) });
  return ret;
};
var scaleSeriesPoints = function(series2, scales, rotated) {
  return series2.map(function(seriesItem) {
    return scalePoints(seriesItem, scales, rotated);
  });
};
var getVisibility = function(pane, centerX, centerY, width, height) {
  return centerX - width / 2 < 0 && centerX + width / 2 < 0 || centerX - width / 2 > pane.width && centerX + width / 2 > pane.width || centerY - height / 2 < 0 && centerY + height / 2 < 0 || centerY - height / 2 > pane.height && centerY + height / 2 > pane.height ? "hidden" : "visible";
};
var adjustBarSize = function(bar, _a3) {
  var width = _a3.width, height = _a3.height;
  var x2 = Math.max(0, bar.x);
  var y2 = Math.max(0, bar.y);
  return {
    x: x2,
    y: y2,
    width: Math.min(width, bar.x + bar.width) - x2,
    height: Math.min(height, bar.y + bar.height) - y2
  };
};
var isValuesChanged = function(previous, current) {
  return Object.entries(previous).some(function(el) {
    return el[1] !== current[el[0]];
  });
};
var isCoordinatesChanged = function(_a3, _b2) {
  var prevCoordinates = _a3.coordinates;
  var coordinates = _b2.coordinates;
  if (prevCoordinates.length !== coordinates.length) {
    return true;
  }
  return prevCoordinates.some(function(el, index) {
    return el.arg !== coordinates[index].arg || el.val !== coordinates[index].val;
  });
};
var isScalesChanged = function(previous, current) {
  return !rangesEqual(previous.argScale.range(), current.argScale.range()) || !rangesEqual(previous.valScale.range(), current.valScale.range());
};
var buildSeriesToStackMap = function(stacks) {
  var result = {};
  stacks.forEach(function(_a3, i) {
    var series2 = _a3.series;
    series2.forEach(function(name) {
      result[name] = i;
    });
  });
  return result;
};
var getStackedPointTransformer = function(getPointTransformer) {
  var wrapper = function(series2) {
    var transform = getPointTransformer(series2);
    var valueScale = series2.valueScale;
    return function(point5) {
      var ret = transform(point5);
      return __assign(__assign({}, ret), { startVal: valueScale(point5.value0) });
    };
  };
  Object.assign(wrapper, getPointTransformer);
  return wrapper;
};
var collectStacks = function(seriesList, seriesToStackMap, stacksKeys, seriesPositions) {
  seriesList.forEach(function(_a3) {
    var name = _a3.name, valueField = _a3.valueField;
    var stackId = seriesToStackMap[name];
    if (stackId === void 0) {
      return;
    }
    if (!stacksKeys[stackId]) {
      stacksKeys[stackId] = [];
    }
    seriesPositions[name] = stacksKeys[stackId].length;
    stacksKeys[stackId].push(valueField);
  });
  Object.keys(stacksKeys).forEach(function(stackId) {
    if (stacksKeys[stackId].length === 1) {
      delete stacksKeys[stackId];
    }
  });
};
var getStackedData = function(stacksKeys, dataItems, offset, order) {
  var result = {};
  Object.keys(stacksKeys).forEach(function(stackId) {
    result[stackId] = stack_default().keys(stacksKeys[stackId]).order(order).offset(offset)(dataItems);
  });
  return result;
};
var buildStackedSeries = function(series2, dataItems) {
  var points = series2.points.map(function(point5) {
    var _a3 = __read(dataItems[point5.index], 2), value0 = _a3[0], value = _a3[1];
    return __assign(__assign({}, point5), { value, value0 });
  });
  var stackedSeries = __assign(__assign({}, series2), { points, isStacked: true });
  if (series2.getPointTransformer.isStartedFromZero) {
    stackedSeries.getPointTransformer = getStackedPointTransformer(series2.getPointTransformer);
  }
  return stackedSeries;
};
var applyStacking = function(seriesList, dataItems, seriesToStackMap, offset, order) {
  var stacksKeys = {};
  var seriesPositions = {};
  collectStacks(seriesList, seriesToStackMap, stacksKeys, seriesPositions);
  if (Object.keys(stacksKeys).length === 0) {
    return seriesList;
  }
  var stackedData = getStackedData(stacksKeys, dataItems, offset, order);
  return seriesList.map(function(seriesItem) {
    var stackId = seriesToStackMap[seriesItem.name];
    var stackData = stackedData[stackId];
    if (!stackData) {
      return seriesItem;
    }
    var position = seriesPositions[seriesItem.name];
    return buildStackedSeries(seriesItem, stackData[position]);
  });
};
var getGroupName = function(series2, i, seriesToStackMap) {
  var stackId = seriesToStackMap[series2.name];
  return stackId >= 0 ? String(stackId) : "group-".concat(i);
};
var getGroupedPointTransformer = function(getPointTransformer, groupCount, groupOffset) {
  var wrapper = function(series2) {
    var transform = getPointTransformer(series2);
    var widthCoeff = 1 / groupCount;
    return function(point5) {
      var original = transform(point5);
      var arg = original.arg - original.maxBarWidth * (0.5 - 0.5 * widthCoeff - groupOffset * widthCoeff);
      var result = __assign(__assign({}, original), { arg, maxBarWidth: original.maxBarWidth / groupCount });
      return result;
    };
  };
  Object.assign(wrapper, getPointTransformer);
  return wrapper;
};
var applyGrouping = function(seriesList, seriesToStackMap) {
  var groups = /* @__PURE__ */ new Set();
  seriesList.forEach(function(seriesItem, i) {
    if (seriesItem.getPointTransformer.isBroad) {
      groups.add(getGroupName(seriesItem, i, seriesToStackMap));
    }
  });
  if (groups.size < 2) {
    return seriesList;
  }
  var scale = band().domain(Array.from(groups)).range([0, groups.size]);
  return seriesList.map(function(seriesItem, i) {
    if (!seriesItem.getPointTransformer.isBroad) {
      return seriesItem;
    }
    var getPointTransformer = getGroupedPointTransformer(seriesItem.getPointTransformer, groups.size, scale(getGroupName(seriesItem, i, seriesToStackMap)));
    return __assign(__assign({}, seriesItem), { getPointTransformer });
  });
};
var getStackedSeries = function(seriesList, dataItems, _a3) {
  var stacks = _a3.stacks, offset = _a3.offset, order = _a3.order;
  var map = buildSeriesToStackMap(stacks);
  var stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);
  var groupedSeriesList = applyGrouping(stackedSeriesList, map);
  return groupedSeriesList;
};
var resetDomainItems = function(domains) {
  var result = {};
  Object.keys(domains).forEach(function(key) {
    result[key] = __assign(__assign({}, domains[key]), { domain: [] });
  });
  return result;
};
var extendDomainsWithAdditionalItems = function(domains, series2) {
  var _a3;
  var items = series2.points.map(function(point5) {
    return point5.value0;
  });
  var key = getValueDomainName(series2.scaleName);
  var domain = updateDomainItems(domains[key], items);
  return domain !== domains[key] ? __assign(__assign({}, domains), (_a3 = {}, _a3[key] = domain, _a3)) : domains;
};
var getStackedDomains = function(domains, seriesList) {
  var stackedSeries = seriesList.filter(function(series2) {
    return series2.isStacked;
  });
  if (!stackedSeries.length) {
    return domains;
  }
  var rebuiltDomains = seriesList.reduce(extendDomains, resetDomainItems(domains));
  return stackedSeries.reduce(extendDomainsWithAdditionalItems, rebuiltDomains);
};
var easeOutCubic = function(t) {
  return (t - 1) * (t - 1) * (t - 1) + 1;
};
var getDelay = function(index, isStart) {
  return isStart ? index * 30 : 0;
};
var getStartVal$1 = function(scales) {
  return scales.valScale.copy().clamp(true)(0);
};
var getPathStart = function(scales, _a3) {
  var coordinates = _a3.coordinates;
  var start = getStartVal$1(scales);
  return { coordinates: coordinates.map(function(coord) {
    return { arg: coord.arg, val: start, startVal: start };
  }) };
};
var getPointStart = function(scales, _a3) {
  var arg = _a3.arg;
  var start = getStartVal$1(scales);
  return { arg, val: start, startVal: start };
};
var getPieStart = function(scales, _a3) {
  var startAngle = _a3.startAngle, endAngle = _a3.endAngle;
  return { innerRadius: 0, outerRadius: 0, startAngle, endAngle };
};
var compareTargets = function(target1, target2) {
  return target1.series === target2.series && target1.point === target2.point;
};
var selectTarget = function(targets, currentTarget) {
  var candidate = targets[0];
  if (!currentTarget) {
    return candidate;
  }
  if (!candidate) {
    return null;
  }
  return compareTargets(candidate, currentTarget) ? void 0 : candidate;
};
var processPointerMove = function(targets, currentTarget, notify) {
  var nextTarget = selectTarget(targets, currentTarget);
  if (nextTarget === void 0) {
    return void 0;
  }
  if (notify) {
    notify(nextTarget);
  }
  return nextTarget;
};
var getOffset = function(element) {
  var _a3 = element.getBoundingClientRect(), left = _a3.left, top = _a3.top;
  var defaultView = element.ownerDocument.defaultView;
  var _b2 = defaultView, pageXOffset = _b2.pageXOffset, pageYOffset = _b2.pageYOffset;
  return [left + pageXOffset, top + pageYOffset];
};
var getEventCoords = function(e, offset) {
  var _a3 = e.touches ? e.touches[0] : e, pageX = _a3.pageX, pageY = _a3.pageY;
  return [pageX - offset[0], pageY - offset[1]];
};
var getParameters = function(series2, target) {
  var currentSeries = series2.find(function(_a3) {
    var name = _a3.name;
    return target.series === name;
  });
  var item = currentSeries.points.find(function(point5) {
    return point5.index === target.point;
  });
  return {
    element: currentSeries.getPointTransformer.getTargetElement(item),
    text: "".concat(item.value)
  };
};
var createReference = function(rect, rootRef) {
  return {
    // These two fields together with *width* and *height* are left with stub data for
    // simplicity reasons - they seem to be unused by *Popper*.
    clientWidth: 0,
    clientHeight: 0,
    getBoundingClientRect: function() {
      var offset = getOffset(rootRef.current);
      var htmlRect = rootRef.current.ownerDocument.documentElement.getBoundingClientRect();
      var left = rect[0] + offset[0] + htmlRect.left;
      var right = rect[2] + offset[0] + htmlRect.left;
      var top = rect[1] + offset[1] + htmlRect.top;
      var bottom = rect[3] + offset[1] + htmlRect.top;
      return {
        left,
        top,
        right,
        bottom,
        width: right - left,
        height: bottom - top
      };
    }
  };
};
var processHandleTooltip = function(targets, currentTarget, onTargetItemChange) {
  var filterTargets = targets.filter(function(target) {
    return target.point !== void 0;
  });
  return processPointerMove(filterTargets, currentTarget, onTargetItemChange);
};
var getArgumentBounds = function(viewport) {
  return viewport && viewport.argumentStart !== void 0 && viewport.argumentEnd !== void 0 ? [viewport.argumentStart, viewport.argumentEnd] : null;
};
var getValueBounds = function(viewport) {
  return viewport && viewport.valueStart !== void 0 && viewport.valueEnd !== void 0 ? [viewport.valueStart, viewport.valueEnd] : null;
};
var getValueScaleName = function(viewport) {
  return getValueDomainName(viewport && viewport.scaleName);
};
var getDefaultBounds = function(scale) {
  var domain = scale.domain();
  return [domain[0], domain[domain.length - 1]];
};
var proportionallyExtendRange = function(range, subRange) {
  var p = (subRange[0] - subRange[1]) / (range[0] - range[1]);
  var q = subRange[0] - p * range[0];
  return [
    (range[0] - q) / p,
    (range[1] - q) / p
  ];
};
var adjustRange = function(domain, bounds, range) {
  var scale = makeScale(domain, range);
  var subRange = scaleBounds(scale, bounds);
  return rangesEqual(subRange, range) ? range : proportionallyExtendRange(range, subRange);
};
var update = function(ranges, changes, key, domain, bounds) {
  var newRange = adjustRange(domain, bounds, ranges[key]);
  if (newRange !== ranges[key]) {
    changes[key] = newRange;
  }
};
var adjustLayout = function(domains, ranges, viewport) {
  var changes = {};
  var argumentBounds = getArgumentBounds(viewport);
  if (argumentBounds) {
    update(ranges, changes, ARGUMENT_DOMAIN, domains[ARGUMENT_DOMAIN], argumentBounds);
  }
  var valueBounds = getValueBounds(viewport);
  if (valueBounds) {
    update(ranges, changes, VALUE_DOMAIN, domains[getValueScaleName(viewport)], valueBounds);
  }
  return Object.keys(changes).length ? __assign(__assign({}, ranges), changes) : ranges;
};
var boundsForScale = function(name, scales, currentBounds, interaction, type, delta, anchor, range) {
  if (!checkInteraction(interaction, type)) {
    return null;
  }
  var scale = scales[name];
  var bounds = currentBounds || getDefaultBounds(scale);
  var newBounds;
  if (type === "pan") {
    newBounds = moveBounds(scale, bounds, delta);
  } else if (type === "zoom") {
    newBounds = range ? invertBoundsRange(scale, range) : growBounds(scale, bounds, delta, anchor);
  }
  return newBounds !== bounds ? newBounds : null;
};
var getViewport = function(scales, rotated, _a3, type, deltas, anchors, ranges, viewport, onViewportChange) {
  var _b2 = __read(_a3, 2), argInteraction = _b2[0], valInteraction = _b2[1];
  var argIndex = Number(rotated);
  var valIndex = 1 - argIndex;
  var changes = {};
  var argumentBounds = boundsForScale(ARGUMENT_DOMAIN, scales, getArgumentBounds(viewport), argInteraction, type, deltas ? deltas[argIndex] : 0, anchors ? anchors[argIndex] : 0, ranges ? ranges[argIndex] : void 0);
  var valueBounds = boundsForScale(getValueScaleName(viewport), scales, getValueBounds(viewport), valInteraction, type, deltas ? deltas[valIndex] : 0, anchors ? anchors[valIndex] : 0, ranges ? ranges[valIndex] : void 0);
  if (argumentBounds) {
    changes.argumentStart = argumentBounds[0];
    changes.argumentEnd = argumentBounds[1];
  }
  if (valueBounds) {
    changes.valueStart = valueBounds[0];
    changes.valueEnd = valueBounds[1];
  }
  if (Object.keys(changes).length) {
    var newViewport = __assign(__assign({}, viewport), changes);
    if (onViewportChange) {
      onViewportChange(newViewport);
    }
    return { viewport: newViewport };
  }
  return null;
};
var getDeltaForTouches = function(touches) {
  var deltaX = touches[0].pageX - touches[1].pageX;
  var deltaY = touches[0].pageY - touches[1].pageY;
  var delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  var center = [
    (touches[0].pageX + touches[1].pageX) / 2,
    (touches[0].pageY + touches[1].pageY) / 2
  ];
  return { delta, center };
};
var isKeyPressed = function(event, key) {
  return event["".concat(key, "Key")];
};
var getWheelDelta = function(_a3) {
  var wheelDelta = _a3.wheelDelta, deltaY = _a3.deltaY;
  return wheelDelta !== void 0 ? wheelDelta : deltaY * -30;
};
var isMultiTouch = function(e) {
  return e.touches && e.touches.length === 2;
};
var attachEvents = function(node, handlers) {
  Object.keys(handlers).forEach(function(el) {
    node.addEventListener(el, handlers[el], { passive: false });
  });
};
var detachEvents = function(node, handlers) {
  Object.keys(handlers).forEach(function(el) {
    node.removeEventListener(el, handlers[el]);
  });
};
var getRect$1 = function(rotated, interactionWithArguments, interactionWithValues, initial, current, pane) {
  var isZoomArgument = checkInteraction(interactionWithArguments, "zoom");
  var isZoomValue = checkInteraction(interactionWithValues, "zoom");
  var isXFixed = rotated ? isZoomValue : isZoomArgument;
  var isYFixed = rotated ? isZoomArgument : isZoomValue;
  var x2 = isXFixed ? Math.min(initial[0], current[0]) : 0;
  var width = isXFixed ? Math.abs(initial[0] - current[0]) : pane.width;
  var y2 = isYFixed ? Math.min(initial[1], current[1]) : 0;
  var height = isYFixed ? Math.abs(initial[1] - current[1]) : pane.height;
  return {
    x: x2,
    y: y2,
    width,
    height
  };
};
var checkInteraction = function(interaction, type) {
  return interaction === "both" || interaction === type;
};
var setCursorType = function(node, type) {
  var defaultType = "pointer";
  node.style.cursor = type ? type : defaultType;
};
var isReadyToRenderSeries = function(_a3, _b2, isPreviousDataEmpty, axesExist) {
  var pane = _a3.pane, restLayouts = __rest(_a3, ["pane"]);
  var current = _b2.current;
  if (!pane.width && !pane.height) {
    return false;
  }
  var bbox = { width: current.clientWidth, height: current.clientHeight };
  var width = pane.width;
  var height = pane.height;
  Object.entries(restLayouts).forEach(function(el) {
    var orientation = el[0].split("-")[0];
    if (orientation === "top" || orientation === "bottom") {
      height += el[1].height;
    } else {
      width += el[1].width;
    }
  });
  return Math.abs(bbox.width - width) < DIFFERENCE && Math.abs(bbox.height - height) < DIFFERENCE && isPreviousDataEmptyOrNoAxes(isPreviousDataEmpty, axesExist);
};
var isPreviousDataEmptyOrNoAxes = function(isPreviousDataEmpty, axesExist) {
  return !isPreviousDataEmpty || !axesExist;
};
var getSegmentLength = function(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
};
var createContext = function() {
  return document.createElement("canvas").getContext("2d");
};
var createCanvasAbusingHitTester = function(makePath, points, rotated) {
  var ctx = createContext();
  var path2 = makePath(rotated);
  path2.context(ctx);
  path2(points);
  return function(_a3) {
    var _b2 = __read(_a3, 2), x2 = _b2[0], y2 = _b2[1];
    return ctx.isPointInPath(x2, y2);
  };
};
var LINE_POINT_SIZE = 20;
var LINE_TOLERANCE = 10;
var getDistance = function(_a3, _b2, rotated) {
  var _c = __read(_a3, 2), px = _c[0], py = _c[1];
  var arg = _b2.arg, val = _b2.val;
  var x2 = rotated ? val : arg;
  var y2 = rotated ? arg : val;
  return getSegmentLength(px - x2, py - y2);
};
var createContinuousSeriesHitTesterCreator = function(makePath) {
  return function(points, rotated) {
    var fallbackHitTest = createCanvasAbusingHitTester(makePath, points, rotated);
    return function(target) {
      var minDistance = Number.MAX_VALUE;
      var minIndex = 0;
      var list = [];
      points.forEach(function(point5, i) {
        var distance = getDistance(target, point5, rotated);
        if (distance <= LINE_POINT_SIZE) {
          list.push({ distance, index: point5.index });
        }
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i;
        }
      });
      if (!list.length && fallbackHitTest(target)) {
        list.push({ index: points[minIndex].index, distance: minDistance });
      }
      return list.length ? { points: list } : null;
    };
  };
};
var createPointsEnumeratingHitTesterCreator = function(hitTestPoint) {
  return function(points, rotated) {
    return function(target) {
      var list = [];
      points.forEach(function(point5) {
        var status = hitTestPoint(target, point5, rotated);
        if (status) {
          list.push({ index: point5.index, distance: status.distance });
        }
      });
      return list.length ? { points: list } : null;
    };
  };
};
var createAreaHitTester = createContinuousSeriesHitTesterCreator(function(rotated) {
  var path2 = area_default();
  var hitArea = rotated ? dRotateArea : dArea;
  if (rotated) {
    path2.x1(hitArea.x1());
    path2.x0(hitArea.x0());
    path2.y(hitArea.y());
  } else {
    path2.x(hitArea.x());
    path2.y1(hitArea.y1());
    path2.y0(hitArea.y0());
  }
  return path2;
});
var createLineHitTester = createContinuousSeriesHitTesterCreator(function(rotated) {
  var path2 = area_default();
  var hitLine = rotated ? dRotateLine : dLine;
  if (rotated) {
    var getX_1 = hitLine.x();
    path2.y(hitLine.y());
    path2.x0(function(point5) {
      return getX_1(point5) + LINE_TOLERANCE;
    });
    path2.x1(function(point5) {
      return getX_1(point5) - LINE_TOLERANCE;
    });
  } else {
    var getY_1 = hitLine.y();
    path2.x(hitLine.x());
    path2.y1(function(point5) {
      return getY_1(point5) - LINE_TOLERANCE;
    });
    path2.y0(function(point5) {
      return getY_1(point5) + LINE_TOLERANCE;
    });
  }
  return path2;
});
var createSplineHitTester = createContinuousSeriesHitTesterCreator(function(rotated) {
  var path2 = area_default();
  var hitSpline = rotated ? dRotateSpline : dSpline;
  if (rotated) {
    var getX_2 = hitSpline.x();
    path2.y(hitSpline.y());
    path2.x1(function(point5) {
      return getX_2(point5) - LINE_TOLERANCE;
    });
    path2.x0(function(point5) {
      return getX_2(point5) + LINE_TOLERANCE;
    });
  } else {
    var getY_2 = hitSpline.y();
    path2.x(hitSpline.x());
    path2.y1(function(point5) {
      return getY_2(point5) - LINE_TOLERANCE;
    });
    path2.y0(function(point5) {
      return getY_2(point5) + LINE_TOLERANCE;
    });
  }
  path2.curve(hitSpline.curve());
  return path2;
});
var hitTestRect = function(dx, dy, halfX, halfY) {
  return Math.abs(dx) <= halfX && Math.abs(dy) <= halfY ? {
    distance: getSegmentLength(dx, dy)
  } : null;
};
var createBarHitTester = createPointsEnumeratingHitTesterCreator(function(_a3, point5, rotated) {
  var _b2 = __read(_a3, 2), px = _b2[0], py = _b2[1];
  var _c = point5, arg = _c.arg, val = _c.val, startVal = _c.startVal, barWidth = _c.barWidth, maxBarWidth = _c.maxBarWidth;
  var halfWidth = maxBarWidth * barWidth / 2;
  var halfHeight = Math.abs(val - startVal) / 2;
  var centerVal = (val + startVal) / 2;
  var xCenter = rotated ? centerVal : arg;
  var yCenter = rotated ? arg : centerVal;
  return hitTestRect(px - xCenter, py - yCenter, rotated ? halfHeight : halfWidth, rotated ? halfWidth : halfHeight);
});
var createScatterHitTester = createPointsEnumeratingHitTesterCreator(function(_a3, obj, rotated) {
  var _b2 = __read(_a3, 2), px = _b2[0], py = _b2[1];
  var point5 = obj.point;
  var distance = getDistance([px, py], obj, rotated);
  return distance <= point5.size / 2 ? { distance } : null;
});
var mapAngleTod3 = function(angle) {
  var ret = angle + Math.PI / 2;
  return ret >= 0 ? ret : ret + Math.PI * 2;
};
var createPieHitTester = createPointsEnumeratingHitTesterCreator(function(_a3, point5) {
  var _b2 = __read(_a3, 2), px = _b2[0], py = _b2[1];
  var _c = point5, x2 = _c.arg, y2 = _c.val, innerRadius = _c.innerRadius, outerRadius = _c.outerRadius, startAngle = _c.startAngle, maxRadius = _c.maxRadius, endAngle = _c.endAngle;
  var inner = innerRadius * maxRadius;
  var outer = outerRadius * maxRadius;
  var rCenter = (inner + outer) / 2;
  var angleCenter = (startAngle + endAngle) / 2;
  var halfRadius = (outer - inner) / 2;
  var halfAngle = Math.abs(startAngle - endAngle) / 2;
  var dx = px - x2;
  var dy = py - y2;
  var r = getSegmentLength(dx, dy);
  var angle = mapAngleTod3(Math.atan2(dy, dx));
  return hitTestRect(r - rCenter, angle - angleCenter, halfRadius, halfAngle);
});
var buildFilter = function(targets) {
  var result = {};
  targets.forEach(function(_a3) {
    var series2 = _a3.series, point5 = _a3.point;
    (result[series2] = result[series2] || /* @__PURE__ */ new Set()).add(point5);
  });
  return result;
};
var changeSeriesState = function(seriesList, targets, state) {
  if (targets.length === 0) {
    return seriesList;
  }
  var filter = buildFilter(targets);
  var matches = 0;
  var result = seriesList.map(function(seriesItem) {
    var set = filter[seriesItem.name];
    if (!set) {
      return seriesItem;
    }
    matches += 1;
    var props = { state };
    if (set.size) {
      props.points = seriesItem.points.map(function(point5) {
        return set.has(point5.index) ? __assign(__assign({}, point5), { state }) : point5;
      });
    }
    return __assign(__assign({}, seriesItem), props);
  });
  return matches > 0 ? result : seriesList;
};
var getDefaultLegendItems = function(series2) {
  return series2.map(function(_a3) {
    var text = _a3.name, color = _a3.color;
    return { text, color };
  });
};
var getPieLegendItems = function(series2) {
  return series2[0].points.map(function(_a3) {
    var text = _a3.argument, color = _a3.color;
    return { text, color };
  });
};
var isSinglePieSeriesCase = function(series2) {
  return series2.length === 1 && "innerRadius" in series2[0] && "outerRadius" in series2[0];
};
var getLegendItems = function(series2) {
  return (isSinglePieSeriesCase(series2) ? getPieLegendItems : getDefaultLegendItems)(series2);
};
var DISTANCE_THRESHOLD = 20;
var compareHitTargets = function(t1, t2) {
  var distanceDelta = t1.distance - t2.distance;
  if (Math.abs(distanceDelta) <= DISTANCE_THRESHOLD) {
    var orderDelta = t2.order - t1.order;
    return orderDelta !== 0 ? orderDelta : distanceDelta;
  }
  return distanceDelta;
};
var buildEventHandler = function(seriesList, handlers) {
  var hitTesters = null;
  var createHitTesters = function() {
    var obj = {};
    seriesList.forEach(function(seriesItem) {
      obj[seriesItem.symbolName] = seriesItem.createHitTester(seriesItem.points, seriesItem.rotated);
    });
    return obj;
  };
  return function(e) {
    var location = getEventCoords(e, getOffset(e.currentTarget));
    hitTesters = hitTesters || createHitTesters();
    var targets = [];
    seriesList.forEach(function(_a3) {
      var series2 = _a3.name, order = _a3.index, symbolName = _a3.symbolName;
      var status = hitTesters[symbolName](location);
      if (status) {
        targets.push.apply(targets, __spreadArray([], __read(status.points.map(function(point5) {
          return {
            series: series2,
            order,
            point: point5.index,
            distance: point5.distance
          };
        })), false));
      }
    });
    targets.sort(compareHitTargets);
    var arg = { location, targets, event: e.nativeEvent };
    handlers.forEach(function(handler) {
      return handler(arg);
    });
  };
};
var buildLeaveEventHandler = function(handlers) {
  return function(e) {
    var location = getEventCoords(e, getOffset(e.currentTarget));
    var arg = { location, targets: [] };
    handlers.forEach(function(handler) {
      return handler(arg);
    });
  };
};
var buildEventHandlers = function(seriesList, _a3) {
  var clickHandlers = _a3.clickHandlers, pointerMoveHandlers = _a3.pointerMoveHandlers;
  var handlers = {};
  if (!hasWindow())
    return handlers;
  if (clickHandlers.length) {
    handlers.click = buildEventHandler(seriesList, clickHandlers);
  }
  if (pointerMoveHandlers.length) {
    var moveHandler = buildEventHandler(seriesList, pointerMoveHandlers);
    var leaveHandler = buildLeaveEventHandler(pointerMoveHandlers);
    if ("ontouchstart" in window) {
      handlers.touchstart = moveHandler;
    } else {
      handlers.mousemove = moveHandler;
      handlers.mouseleave = leaveHandler;
    }
  }
  return handlers;
};
var getProgress = function(_a3) {
  var elapsed = _a3.elapsed, total = _a3.total;
  return Math.min(elapsed / total, 1);
};
var runAnimation = function(setAttributes, getNewPositions, easing, duration, delay) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      var time = {
        start: Date.now(),
        total: duration,
        elapsed: 0
      };
      var step = function() {
        time.elapsed = Date.now() - time.start;
        var progress = getProgress(time);
        setAttributes(getNewPositions(easing(progress)));
        if (progress < 1)
          requestAnimationFrame(step);
      };
      resolve(requestAnimationFrame(step));
    }, delay);
  });
};
var buildAnimation = function(easing, duration) {
  return function(startCoords, endCoords, processAnimation, setAttributes, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    var animationID;
    var stop = function() {
      if (animationID) {
        cancelAnimationFrame(animationID);
        animationID = void 0;
      }
    };
    var run = function(start, end, delayValue) {
      animationID = runAnimation(setAttributes, processAnimation(start, end), easing, duration, delayValue).then(function(res) {
        animationID = res;
      });
    };
    run(startCoords, endCoords, delay);
    return {
      update: function(updatedStartCoords, updatedEndCoords, updatedDelay) {
        if (updatedDelay === void 0) {
          updatedDelay = 0;
        }
        stop();
        run(updatedStartCoords, updatedEndCoords, updatedDelay);
      },
      stop
    };
  };
};
var lerp = function(a2, b, t) {
  return a2 + t * (b - a2);
};
var processPointAnimation = function(startCoords, endCoords) {
  return function(progress) {
    return {
      arg: lerp(startCoords.arg, endCoords.arg, progress),
      val: lerp(startCoords.val, endCoords.val, progress)
    };
  };
};
var processBarAnimation = function(startCoords, endCoords) {
  return function(progress) {
    return {
      arg: lerp(startCoords.arg, endCoords.arg, progress),
      val: lerp(startCoords.val, endCoords.val, progress),
      startVal: lerp(startCoords.startVal, endCoords.startVal, progress)
    };
  };
};
var processLineAnimation = function(_a3, _b2) {
  var coordinates = _a3.coordinates;
  var endCoordinates = _b2.coordinates;
  return function(progress) {
    return {
      coordinates: endCoordinates.map(function(coord, index) {
        var startCurCoord = coordinates[index];
        return __assign(__assign({}, coord), { arg: lerp(startCurCoord.arg, coord.arg, progress), val: lerp(startCurCoord.val, coord.val, progress) });
      })
    };
  };
};
var processAreaAnimation = function(_a3, _b2) {
  var coordinates = _a3.coordinates;
  var endCoordinates = _b2.coordinates;
  return function(progress) {
    return {
      coordinates: endCoordinates.map(function(coord, index) {
        var startCurCoord = coordinates[index];
        return __assign(__assign({}, coord), { arg: lerp(startCurCoord.arg, coord.arg, progress), val: lerp(startCurCoord.val, coord.val, progress), startVal: lerp(startCurCoord.startVal, coord.startVal, progress) });
      })
    };
  };
};
var processPieAnimation = function(start, end) {
  return function(progress) {
    return {
      innerRadius: lerp(start.innerRadius, end.innerRadius, progress),
      outerRadius: lerp(start.outerRadius, end.outerRadius, progress),
      startAngle: lerp(start.startAngle, end.startAngle, progress),
      endAngle: lerp(start.endAngle, end.endAngle, progress)
    };
  };
};

// node_modules/@devexpress/dx-react-chart/dist/dx-react-chart.es.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p))
          t[p] = s2[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s2, e) {
  var t = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
      t[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t[p[i]] = s2[p[i]];
    }
  return t;
}
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray2(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || from);
}
var series = [];
var BasicData = function(_a3) {
  var data = _a3.data, rotated = _a3.rotated;
  return (0, import_react.createElement)(
    Plugin,
    { name: "Basis" },
    (0, import_react.createElement)(Getter, { name: "data", value: data }),
    (0, import_react.createElement)(Getter, { name: "domains", value: defaultDomains }),
    (0, import_react.createElement)(Getter, { name: "series", value: series }),
    (0, import_react.createElement)(Getter, { name: "rotated", value: rotated })
  );
};
var getScales = function(_a3) {
  var domains = _a3.domains, ranges = _a3.ranges;
  return buildScales(domains, ranges);
};
var getSeries = function(_a3) {
  var series2 = _a3.series, scales = _a3.scales, rotated = _a3.rotated;
  return scaleSeriesPoints(series2, scales, rotated);
};
var ChartCore = function(_super) {
  __extends(ChartCore2, _super);
  function ChartCore2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ChartCore2.prototype.render = function() {
    return (0, import_react.createElement)(
      Plugin,
      null,
      (0, import_react.createElement)(Getter, { name: "scales", computed: getScales }),
      (0, import_react.createElement)(Getter, { name: "series", computed: getSeries })
    );
  };
  return ChartCore2;
}(import_react.PureComponent);
var AxesLayout = function(_super) {
  __extends(AxesLayout2, _super);
  function AxesLayout2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ref = (0, import_react.createRef)();
    return _this;
  }
  AxesLayout2.prototype.render = function() {
    return (0, import_react.createElement)(
      Plugin,
      null,
      (0, import_react.createElement)(Getter, { name: "centerDivRef", value: this.ref }),
      (0, import_react.createElement)(
        Template,
        { name: "canvas" },
        (0, import_react.createElement)(
          "div",
          { id: "center-center", ref: this.ref, style: { display: "flex", flexDirection: "column", flexGrow: 1 } },
          (0, import_react.createElement)(
            "div",
            { id: "".concat(TOP, "-axis-container"), style: { display: "flex", flexDirection: "row" } },
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(TOP, "-").concat(LEFT, "-axis") }),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(TOP, "-axis") }),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(TOP, "-").concat(RIGHT, "-axis") })
          ),
          (0, import_react.createElement)(
            "div",
            { id: "center-axis-container", style: { display: "flex", flexDirection: "row", flexGrow: 1 } },
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(LEFT, "-axis") }),
            (0, import_react.createElement)(TemplatePlaceholder, null),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(RIGHT, "-axis") })
          ),
          (0, import_react.createElement)(
            "div",
            { id: "".concat(BOTTOM, "-axis-container"), style: { display: "flex", flexDirection: "row" } },
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(BOTTOM, "-").concat(LEFT, "-axis") }),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(BOTTOM, "-axis") }),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(BOTTOM, "-").concat(RIGHT, "-axis") })
          )
        )
      )
    );
  };
  return AxesLayout2;
}(import_react.PureComponent);
var SpaceFillingRects = function(_super) {
  __extends(SpaceFillingRects2, _super);
  function SpaceFillingRects2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SpaceFillingRects2.prototype.render = function() {
    var placeholders2 = this.props.placeholders;
    return (0, import_react.createElement)(Plugin, { name: "SpaceFillingRects" }, placeholders2.map(function(name) {
      return (0, import_react.createElement)(
        Template,
        { name, key: name },
        (0, import_react.createElement)(TemplateConnector, null, function(_a3) {
          var layouts = _a3.layouts;
          var key = name.slice(name.indexOf("-") + 1);
          var width = Object.keys(layouts).reduce(function(prev, cur) {
            if (cur.includes(key)) {
              return prev + layouts[cur].width;
            }
            return prev;
          }, 0);
          return (0, import_react.createElement)("div", { id: name, style: { width } });
        })
      );
    }));
  };
  return SpaceFillingRects2;
}(import_react.PureComponent);
var ControllerComponent = function(_super) {
  __extends(ControllerComponent2, _super);
  function ControllerComponent2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isPreviousDataEmpty = true;
    _this.readyToRenderSeriesComputed = function(_a3) {
      var layouts = _a3.layouts, centerDivRef = _a3.centerDivRef, data = _a3.data, axesExist = _a3.axesExist;
      var isPreviousDataEmpty = _this.isPreviousDataEmpty;
      _this.isPreviousDataEmpty = !data.length;
      return isReadyToRenderSeries(layouts, centerDivRef, isPreviousDataEmpty, !!axesExist);
    };
    return _this;
  }
  ControllerComponent2.prototype.render = function() {
    return (0, import_react.createElement)(
      Plugin,
      { name: "ControllerComponent" },
      (0, import_react.createElement)(Getter, { name: "readyToRenderSeries", computed: this.readyToRenderSeriesComputed })
    );
  };
  return ControllerComponent2;
}(import_react.PureComponent);
var EXTRA_PIXELS = 2;
var ClipPath = function(_super) {
  __extends(ClipPath2, _super);
  function ClipPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ClipPath2.prototype.render = function() {
    var _a3 = this.props, id = _a3.id, width = _a3.width, height = _a3.height;
    return (0, import_react.createElement)(
      "defs",
      null,
      (0, import_react.createElement)(
        "clipPath",
        { id },
        (0, import_react.createElement)("rect", { x: -EXTRA_PIXELS / 2, y: -EXTRA_PIXELS / 2, width: width + EXTRA_PIXELS, height: height + EXTRA_PIXELS })
      )
    );
  };
  return ClipPath2;
}(import_react.PureComponent);
var UpdatableSizer = function(_super) {
  __extends(UpdatableSizer2, _super);
  function UpdatableSizer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ref = (0, import_react.createRef)();
    return _this;
  }
  UpdatableSizer2.prototype.componentDidUpdate = function() {
    this.props.onSizeChange(this.ref.current.getSize());
  };
  UpdatableSizer2.prototype.render = function() {
    return (0, import_react.createElement)(Sizer, __assign2({ ref: this.ref }, this.props));
  };
  return UpdatableSizer2;
}(import_react.PureComponent);
var DIV_STYLE = {
  flex: 1,
  zIndex: 1,
  position: "relative",
  width: "100%"
};
var SVG_STYLE = {
  position: "absolute",
  left: 0,
  top: 0,
  overflow: "visible"
};
var SizerContainer = function(_a3) {
  var children = _a3.children, forwardedRef = _a3.forwardedRef;
  return (0, import_react.createElement)("div", { ref: forwardedRef, style: DIV_STYLE }, children);
};
var numDefs = 0;
var getUniqueId = function() {
  numDefs += 1;
  return numDefs;
};
var PaneLayout = function(_super) {
  __extends(PaneLayout2, _super);
  function PaneLayout2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ref = (0, import_react.createRef)();
    _this.clipPathId = "clip_path_".concat(getUniqueId());
    return _this;
  }
  PaneLayout2.prototype.render = function() {
    var _this = this;
    return (0, import_react.createElement)(
      Plugin,
      { name: "PaneLayout" },
      (0, import_react.createElement)(Getter, { name: "rootRef", value: this.ref }),
      (0, import_react.createElement)(Getter, { name: "clipPathId", value: this.clipPathId }),
      (0, import_react.createElement)(Template, { name: "canvas" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a3, _b2) {
          var layouts = _a3.layouts;
          var changeBBox = _b2.changeBBox;
          var _c = layouts.pane, width = _c.width, height = _c.height;
          return (0, import_react.createElement)(
            UpdatableSizer,
            { containerComponent: SizerContainer, onSizeChange: function(size) {
              return changeBBox({ placeholder: "pane", bBox: size });
            } },
            (0, import_react.createElement)(
              "svg",
              __assign2({ ref: _this.ref }, params, { width, height, style: SVG_STYLE }),
              (0, import_react.createElement)(ClipPath, { id: _this.clipPathId, width, height }),
              (0, import_react.createElement)(TemplatePlaceholder, { name: "series" })
            )
          );
        });
      })
    );
  };
  return PaneLayout2;
}(import_react.PureComponent);
var doGetRanges = function(_a3) {
  var layouts = _a3.layouts, rotated = _a3.rotated;
  return getRanges(layouts.pane, rotated);
};
var LayoutManager = function(_super) {
  __extends(LayoutManager2, _super);
  function LayoutManager2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = { bBoxes: { pane: { width: 0, height: 0 } } };
    var stateHelper = createStateHelper(_this);
    _this.changeBBox = stateHelper.applyFieldReducer.bind(stateHelper, "bBoxes", bBoxes);
    return _this;
  }
  LayoutManager2.prototype.render = function() {
    var _a3 = this.props, width = _a3.width, height = _a3.height, Root2 = _a3.rootComponent, restProps = __rest2(_a3, ["width", "height", "rootComponent"]);
    var stateBBoxes = this.state.bBoxes;
    return (0, import_react.createElement)(
      Plugin,
      null,
      (0, import_react.createElement)(Getter, { name: "layouts", value: stateBBoxes }),
      (0, import_react.createElement)(Getter, { name: "ranges", computed: doGetRanges }),
      (0, import_react.createElement)(Action, { name: "changeBBox", action: this.changeBBox }),
      (0, import_react.createElement)(
        Template,
        { name: "root" },
        (0, import_react.createElement)(
          Root2,
          __assign2({ width, height }, restProps),
          (0, import_react.createElement)(TemplatePlaceholder, { name: "canvas" })
        )
      )
    );
  };
  LayoutManager2.defaultProps = {
    width: 0
  };
  return LayoutManager2;
}(import_react.PureComponent);
var ComponentLayout = function() {
  return (0, import_react.createElement)(
    Plugin,
    { name: "ComponentLayout" },
    (0, import_react.createElement)(
      Template,
      { name: "canvas" },
      (0, import_react.createElement)(
        "div",
        { id: "".concat(TOP, "-container"), style: { display: "flex", flexDirection: "row" } },
        (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(TOP, "-").concat(LEFT) }),
        (0, import_react.createElement)(TemplatePlaceholder, { name: TOP }),
        (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(TOP, "-").concat(RIGHT) })
      ),
      (0, import_react.createElement)(
        "div",
        { id: "center-container", style: { display: "flex", flexDirection: "row", flexGrow: 1 } },
        (0, import_react.createElement)(TemplatePlaceholder, { name: LEFT }),
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplatePlaceholder, { name: RIGHT })
      ),
      (0, import_react.createElement)(
        "div",
        { id: "".concat(BOTTOM, "-container"), style: { display: "flex", flexDirection: "row" } },
        (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(BOTTOM, "-").concat(LEFT) }),
        (0, import_react.createElement)(TemplatePlaceholder, { name: BOTTOM }),
        (0, import_react.createElement)(TemplatePlaceholder, { name: "".concat(BOTTOM, "-").concat(RIGHT) })
      )
    )
  );
};
var PaletteBase = function(_super) {
  __extends(PaletteBase2, _super);
  function PaletteBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PaletteBase2.prototype.render = function() {
    var scheme2 = this.props.scheme;
    return (0, import_react.createElement)(
      Plugin,
      { name: "Palette" },
      (0, import_react.createElement)(Getter, { name: "palette", value: scheme2 })
    );
  };
  return PaletteBase2;
}(import_react.PureComponent);
var Palette = PaletteBase;
var Root = function(_super) {
  __extends(Root2, _super);
  function Root2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Root2.prototype.render = function() {
    var _a3 = this.props, children = _a3.children, width = _a3.width, height = _a3.height, style = _a3.style, restProps = __rest2(_a3, ["children", "width", "height", "style"]);
    return (0, import_react.createElement)("div", __assign2({ style: __assign2(__assign2(__assign2({}, style), { height: "".concat(height, "px") }), width ? { width: "".concat(width, "px") } : null) }, restProps), children);
  };
  return Root2;
}(import_react.PureComponent);
var Label = function(_super) {
  __extends(Label2, _super);
  function Label2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Label2.prototype.render = function() {
    return (0, import_react.createElement)("text", __assign2({}, this.props));
  };
  return Label2;
}(import_react.PureComponent);
var scheme = [];
var placeholders = [
  "".concat(TOP, "-").concat(LEFT),
  "".concat(TOP, "-").concat(RIGHT),
  "".concat(BOTTOM, "-").concat(LEFT),
  "".concat(BOTTOM, "-").concat(RIGHT),
  "".concat(TOP, "-").concat(LEFT, "-axis"),
  "".concat(TOP, "-").concat(RIGHT, "-axis"),
  "".concat(BOTTOM, "-").concat(LEFT, "-axis"),
  "".concat(BOTTOM, "-").concat(RIGHT, "-axis")
];
var RawChart = function(_super) {
  __extends(RawChart2, _super);
  function RawChart2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawChart2.prototype.render = function() {
    var _a3 = this.props, data = _a3.data, width = _a3.width, height = _a3.height, children = _a3.children, rotated = _a3.rotated, rootComponent = _a3.rootComponent, restProps = __rest2(_a3, ["data", "width", "height", "children", "rotated", "rootComponent"]);
    return (0, import_react.createElement)(
      PluginHost,
      null,
      (0, import_react.createElement)(BasicData, { data, rotated }),
      (0, import_react.createElement)(Palette, { scheme }),
      (0, import_react.createElement)(LayoutManager, __assign2({ width, height, rootComponent }, restProps)),
      (0, import_react.createElement)(PaneLayout, null),
      (0, import_react.createElement)(AxesLayout, null),
      (0, import_react.createElement)(ComponentLayout, null),
      (0, import_react.createElement)(SpaceFillingRects, { placeholders }),
      children,
      (0, import_react.createElement)(ControllerComponent, null),
      (0, import_react.createElement)(ChartCore, null)
    );
  };
  RawChart2.defaultProps = {
    height: 500,
    rotated: false
  };
  RawChart2.components = {
    rootComponent: "Root"
  };
  return RawChart2;
}(import_react.PureComponent);
var Chart = withComponents({ Root })(RawChart);
Chart.Label = Label;
var Marker = function(_super) {
  __extends(Marker2, _super);
  function Marker2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Marker2.prototype.render = function() {
    var _a3 = this.props, color = _a3.color, restProps = __rest2(_a3, ["color"]);
    return (0, import_react.createElement)(
      "svg",
      __assign2({ fill: color, width: "10", height: "10" }, restProps),
      (0, import_react.createElement)("circle", __assign2({ r: 5, cx: 5, cy: 5 }, restProps))
    );
  };
  return Marker2;
}(import_react.PureComponent);
var RawLegend = function(_super) {
  __extends(RawLegend2, _super);
  function RawLegend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawLegend2.prototype.render = function() {
    var _a3 = this.props, MarkerComponent = _a3.markerComponent, Label2 = _a3.labelComponent, Root2 = _a3.rootComponent, Item = _a3.itemComponent, position = _a3.position, getItems = _a3.getItems;
    var placeholder = position;
    return (0, import_react.createElement)(
      Plugin,
      { name: "Legend" },
      (0, import_react.createElement)(
        Template,
        { name: placeholder },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(getters) {
          return (0, import_react.createElement)(Root2, { name: "legend-".concat(placeholder) }, getItems(getters).map(function(_a4) {
            var text = _a4.text, color = _a4.color;
            return (0, import_react.createElement)(
              Item,
              { key: text },
              (0, import_react.createElement)(MarkerComponent, { name: text, color }),
              (0, import_react.createElement)(Label2, { text })
            );
          }));
        })
      )
    );
  };
  RawLegend2.defaultProps = {
    position: "right",
    getItems: function(_a3) {
      var series2 = _a3.series;
      return getLegendItems(series2);
    }
  };
  RawLegend2.components = {
    rootComponent: "Root",
    itemComponent: "Item",
    markerComponent: "Marker",
    labelComponent: "Label"
  };
  return RawLegend2;
}(import_react.PureComponent);
var Legend = withComponents({ Marker })(RawLegend);
var TitleBase = function(_super) {
  __extends(TitleBase2, _super);
  function TitleBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TitleBase2.prototype.render = function() {
    var _a3 = this.props, Text = _a3.textComponent, text = _a3.text, position = _a3.position;
    var placeholder = position;
    return (0, import_react.createElement)(
      Plugin,
      { name: "Title" },
      (0, import_react.createElement)(
        Template,
        { name: placeholder },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(Text, { text })
      )
    );
  };
  TitleBase2.components = {
    textComponent: "Text"
  };
  TitleBase2.defaultProps = {
    position: "top"
  };
  return TitleBase2;
}(import_react.PureComponent);
var Title = TitleBase;
var declareSeries = function(pluginName, _a3) {
  var components = _a3.components, getPointTransformer = _a3.getPointTransformer, createHitTester = _a3.createHitTester;
  var Component = function(_super) {
    __extends(Component2, _super);
    function Component2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Component2.prototype.render = function() {
      var _a4 = this.props, name = _a4.name, argumentField = _a4.argumentField, valueField = _a4.valueField, scaleName = _a4.scaleName, seriesComponent = _a4.seriesComponent, pointComponent = _a4.pointComponent, color = _a4.color, restProps = __rest2(_a4, ["name", "argumentField", "valueField", "scaleName", "seriesComponent", "pointComponent", "color"]);
      var symbolName = Symbol(name);
      var seriesItem = __assign2(__assign2({ getPointTransformer, createHitTester }, this.props), { symbolName });
      var getSeries2 = function(_a5) {
        var series2 = _a5.series, data = _a5.data, palette = _a5.palette;
        return addSeries(series2, data, palette, seriesItem, restProps);
      };
      var getDomains2 = function(_a5) {
        var series2 = _a5.series, domains = _a5.domains;
        return extendDomains(domains, findSeriesByName(symbolName, series2));
      };
      return (0, import_react.createElement)(
        Plugin,
        { name: pluginName },
        (0, import_react.createElement)(Getter, { name: "series", computed: getSeries2 }),
        (0, import_react.createElement)(Getter, { name: "domains", computed: getDomains2 }),
        (0, import_react.createElement)(
          Template,
          { name: "series" },
          (0, import_react.createElement)(TemplatePlaceholder, null),
          (0, import_react.createElement)(TemplateConnector, null, function(_a5) {
            var series2 = _a5.series, scales = _a5.scales, animation = _a5.animation, rotated = _a5.rotated, layouts = _a5.layouts, clipPathId = _a5.clipPathId, readyToRenderSeries = _a5.readyToRenderSeries;
            var pane = layouts.pane;
            var currentSeries = findSeriesByName(symbolName, series2);
            var currentScales = {
              argScale: scales[ARGUMENT_DOMAIN],
              valScale: scales[getValueDomainName(currentSeries.scaleName)]
            };
            var Path3 = currentSeries.seriesComponent;
            return (0, import_react.createElement)(Path3, { index: currentSeries.index, pointComponent: currentSeries.pointComponent, coordinates: currentSeries.points, rotated, state: currentSeries.state, color: currentSeries.color, scales: currentScales, pane, clipPathId, animation, readyToRenderSeries });
          })
        )
      );
    };
    Component2.defaultProps = {
      name: "defaultSeriesName"
    };
    return Component2;
  }(import_react.PureComponent);
  Component.components = {};
  if (components.Path) {
    Component.components.seriesComponent = "Path";
  }
  if (components.Point) {
    Component.components.pointComponent = "Point";
  }
  return withComponents(components)(Component);
};
var withPatchedProps = function(patch) {
  return function(Target) {
    var Component = function(_super) {
      __extends(Component2, _super);
      function Component2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Component2.prototype.render = function() {
        var props = patch(this.props);
        return (0, import_react.createElement)(Target, __assign2({}, props));
      };
      Component2.components = Target.components;
      return Component2;
    }(import_react.PureComponent);
    return Component;
  };
};
var Scale = function(_super) {
  __extends(Scale2, _super);
  function Scale2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Scale2.prototype.render = function() {
    var _a3 = this.props, name = _a3.name, factory = _a3.factory, modifyDomain = _a3.modifyDomain;
    var args = { factory, modifyDomain };
    var getDomains2 = function(_a4) {
      var domains = _a4.domains;
      return addDomain(domains, name, args);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "Scale" },
      (0, import_react.createElement)(Getter, { name: "domains", computed: getDomains2 })
    );
  };
  return Scale2;
}(import_react.PureComponent);
var ArgumentScale = withPatchedProps(function(props) {
  return __assign2(__assign2({}, props), { name: ARGUMENT_DOMAIN });
})(Scale);
var ValueScale = withPatchedProps(function(props) {
  return __assign2(__assign2({}, props), { name: getValueDomainName(props.name) });
})(Scale);
var getDomains = function(_a3) {
  var domains = _a3.domains, series2 = _a3.series;
  return getStackedDomains(domains, series2);
};
var StackBase = function(_super) {
  __extends(StackBase2, _super);
  function StackBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StackBase2.prototype.render = function() {
    var _a3 = this.props, stacks = _a3.stacks, offset = _a3.offset, order = _a3.order;
    var params = {
      stacks,
      offset,
      order
    };
    var getSeries2 = function(_a4) {
      var series2 = _a4.series, data = _a4.data;
      return getStackedSeries(series2, data, params);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "Stack" },
      (0, import_react.createElement)(Getter, { name: "series", computed: getSeries2 }),
      (0, import_react.createElement)(Getter, { name: "domains", computed: getDomains })
    );
  };
  StackBase2.defaultProps = {
    stacks: [],
    offset: diverging_default,
    order: none_default2
  };
  return StackBase2;
}(import_react.PureComponent);
var Stack = StackBase;
var AnimationBase = function(_super) {
  __extends(AnimationBase2, _super);
  function AnimationBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationBase2.prototype.render = function() {
    var _a3 = this.props, easing = _a3.easing, duration = _a3.duration;
    var buildAnimationGetter = function() {
      return buildAnimation(easing, duration);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "Animation" },
      (0, import_react.createElement)(Getter, { name: "animation", computed: buildAnimationGetter })
    );
  };
  AnimationBase2.defaultProps = {
    easing: easeOutCubic,
    duration: 1e3
  };
  return AnimationBase2;
}(import_react.PureComponent);
var Animation = AnimationBase;
var withStates = function(states) {
  return function(Component) {
    var ComponentWithStates = function(_super) {
      __extends(ComponentWithStates2, _super);
      function ComponentWithStates2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComponentWithStates2.prototype.render = function() {
        var _a3 = this.props, state = _a3.state, restProps = __rest2(_a3, ["state"]);
        var stateFunc = state && states[state];
        var result = stateFunc ? stateFunc(restProps) : restProps;
        return (0, import_react.isValidElement)(result) ? result : (0, import_react.createElement)(Component, __assign2({}, result));
      };
      return ComponentWithStates2;
    }(import_react.PureComponent);
    return ComponentWithStates;
  };
};
var Pattern = function(_super) {
  __extends(Pattern2, _super);
  function Pattern2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Pattern2.prototype.render = function() {
    var _a3 = this.props, id = _a3.id, size = _a3.size, color = _a3.color, opacity = _a3.opacity;
    return (0, import_react.createElement)(
      "defs",
      null,
      (0, import_react.createElement)(
        "pattern",
        { id, width: size, height: size, patternUnits: "userSpaceOnUse" },
        (0, import_react.createElement)("rect", { x: 0, y: 0, width: size, height: size, fill: color, opacity }),
        (0, import_react.createElement)("path", {
          // tslint:disable-next-line: max-line-length
          d: "M ".concat(size / 2, " ").concat(-size / 2, " L ").concat(-size / 2, " ").concat(size / 2, " M 0 ").concat(size, " L ").concat(size, " 0 M ").concat(size * 1.5, " ").concat(size / 2, " L ").concat(size / 2, " ").concat(size * 1.5),
          strokeWidth: 2,
          stroke: color
        })
      )
    );
  };
  Pattern2.defaultProps = {
    size: 6,
    opacity: 0.75
  };
  return Pattern2;
}(import_react.PureComponent);
var withPattern = function(getPatternId, props) {
  return function(Target) {
    return function(targetProps) {
      var color = targetProps.color, restProps = __rest2(targetProps, ["color"]);
      var patternId = getPatternId(targetProps);
      return (0, import_react.createElement)(
        import_react.Fragment,
        null,
        (0, import_react.createElement)(Target, __assign2({ color: "url(#".concat(patternId, ")") }, restProps)),
        (0, import_react.createElement)(Pattern, __assign2({ id: patternId, color }, props))
      );
    };
  };
};
var withAnimation = function(processAnimation, getProps, getStartCoordinates, isValuesChanged2, getDelay2) {
  return function(Component) {
    var ComponentWithAnimation = function(_super) {
      __extends(ComponentWithAnimation2, _super);
      function ComponentWithAnimation2(props) {
        var _this = _super.call(this, props) || this;
        _this.setAttribute = _this.setAttribute.bind(_this);
        return _this;
      }
      ComponentWithAnimation2.prototype.setAttribute = function(state) {
        this.setState(state);
      };
      ComponentWithAnimation2.prototype.componentDidMount = function() {
        var _a3 = this.props, animation = _a3.animation, scales = _a3.scales, index = _a3.index, readyToRenderSeries = _a3.readyToRenderSeries;
        if (!readyToRenderSeries) {
          return;
        }
        var props = getProps(this.props);
        this.processComponent(animation, { scales: {} }, scales, props, {}, index);
      };
      ComponentWithAnimation2.prototype.componentDidUpdate = function(prevProps) {
        var _a3 = this.props, scales = _a3.scales, index = _a3.index, animation = _a3.animation, readyToRenderSeries = _a3.readyToRenderSeries;
        if (!readyToRenderSeries) {
          return;
        }
        this.processComponent(animation, prevProps, scales, getProps(this.props), getProps(prevProps), index);
      };
      ComponentWithAnimation2.prototype.processComponent = function(animation, _a3, scales, props, prevProps, index) {
        var prevScales = _a3.scales;
        if (!animation) {
          this.setAttribute(props);
        } else if (this.animate) {
          if (isScalesChanged(prevScales, scales)) {
            this.setAttribute(props);
          } else if (isValuesChanged2(prevProps, props)) {
            var delay = getDelay2 ? getDelay2(index, false) : 0;
            this.animate.update(prevProps, props, delay);
          }
        } else {
          this.animate = animation(getStartCoordinates(scales, props), props, processAnimation, this.setAttribute, getDelay2 && getDelay2(index, true));
        }
      };
      ComponentWithAnimation2.prototype.componentWillUnmount = function() {
        return this.animate && this.animate.stop();
      };
      ComponentWithAnimation2.prototype.render = function() {
        var _a3 = this.props, readyToRenderSeries = _a3.readyToRenderSeries, restProps = __rest2(_a3, ["readyToRenderSeries"]);
        if (!this.state) {
          return null;
        }
        return (0, import_react.createElement)(Component, __assign2({}, restProps, this.state));
      };
      return ComponentWithAnimation2;
    }(import_react.PureComponent);
    return ComponentWithAnimation;
  };
};
var _a2;
var RawArea = function(_super) {
  __extends(RawArea2, _super);
  function RawArea2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawArea2.prototype.render = function() {
    var _a3 = this.props, path2 = _a3.path, coordinates = _a3.coordinates, animation = _a3.animation, index = _a3.index, state = _a3.state, pointComponent = _a3.pointComponent, color = _a3.color, clipPathId = _a3.clipPathId, pane = _a3.pane, scales = _a3.scales, rotated = _a3.rotated, restProps = __rest2(_a3, ["path", "coordinates", "animation", "index", "state", "pointComponent", "color", "clipPathId", "pane", "scales", "rotated"]);
    var dPath = path2 === void 0 ? rotated ? dRotateArea : dArea : path2;
    return (0, import_react.createElement)("path", __assign2({ clipPath: "url(#".concat(clipPathId, ")"), d: dPath(coordinates), fill: color, opacity: 0.5 }, restProps));
  };
  return RawArea2;
}(import_react.PureComponent);
var Area = withAnimation(processAreaAnimation, function(_a3) {
  var coordinates = _a3.coordinates;
  return { coordinates };
}, getPathStart, isCoordinatesChanged)(withStates((_a2 = {}, _a2[HOVERED] = withPattern(function(_a3) {
  var index = _a3.index, color = _a3.color;
  return "series-".concat(index, "-color-").concat(color, "-hover");
}, { opacity: 0.75 })(RawArea), _a2[SELECTED] = withPattern(function(_a3) {
  var index = _a3.index, color = _a3.color;
  return "series-".concat(index, "-color-").concat(color, "-selection");
}, { opacity: 0.5 })(RawArea), _a2))(RawArea));
var AreaSeries = declareSeries("AreaSeries", {
  getPointTransformer: getAreaPointTransformer,
  createHitTester: createAreaHitTester,
  components: { Path: Area }
});
var PointCollection = function(_super) {
  __extends(PointCollection2, _super);
  function PointCollection2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PointCollection2.prototype.render = function() {
    var _a3 = this.props, pointComponent = _a3.pointComponent, coordinates = _a3.coordinates, index = _a3.index, state = _a3.state, clipPathId = _a3.clipPathId, restProps = __rest2(_a3, ["pointComponent", "coordinates", "index", "state", "clipPathId"]);
    var Point2 = pointComponent;
    return coordinates.map(function(point5) {
      return (0, import_react.createElement)(Point2, __assign2({ key: String(point5.index), seriesIndex: index }, restProps, point5));
    });
  };
  return PointCollection2;
}(import_react.PureComponent);
var _a$12;
var RawBar = function(_super) {
  __extends(RawBar2, _super);
  function RawBar2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawBar2.prototype.render = function() {
    var _a3 = this.props, arg = _a3.arg, val = _a3.val, startVal = _a3.startVal, barWidth = _a3.barWidth, maxBarWidth = _a3.maxBarWidth, animation = _a3.animation, argument = _a3.argument, value = _a3.value, seriesIndex = _a3.seriesIndex, index = _a3.index, state = _a3.state, rotated = _a3.rotated, color = _a3.color, pane = _a3.pane, scales = _a3.scales, restProps = __rest2(_a3, ["arg", "val", "startVal", "barWidth", "maxBarWidth", "animation", "argument", "value", "seriesIndex", "index", "state", "rotated", "color", "pane", "scales"]);
    var width = barWidth * maxBarWidth;
    var bar = dBar(arg, val, startVal, width, rotated);
    var visibility = getVisibility(pane, bar.x + bar.width / 2, bar.y + bar.height, bar.width, bar.height);
    var adjustedBar = visibility === "visible" ? adjustBarSize(bar, pane) : bar;
    return (0, import_react.createElement)("rect", __assign2({}, adjustedBar, { fill: color, visibility }, restProps));
  };
  return RawBar2;
}(import_react.PureComponent);
var Bar = withAnimation(processBarAnimation, function(_a3) {
  var arg = _a3.arg, val = _a3.val, startVal = _a3.startVal;
  return { arg, val, startVal };
}, getPointStart, isValuesChanged)(withStates((_a$12 = {}, _a$12[HOVERED] = withPattern(function(_a3) {
  var seriesIndex = _a3.seriesIndex, index = _a3.index, color = _a3.color;
  return "series-".concat(seriesIndex, "-point-").concat(index, "-color-").concat(color, "-hover");
}, { opacity: 0.75 })(RawBar), _a$12[SELECTED] = withPattern(function(_a3) {
  var seriesIndex = _a3.seriesIndex, index = _a3.index, color = _a3.color;
  return "series-".concat(seriesIndex, "-point-").concat(index, "-color-").concat(color, "-selection");
}, { opacity: 0.5 })(RawBar), _a$12))(RawBar));
var BarSeries = declareSeries("BarSeries", {
  getPointTransformer: getBarPointTransformer,
  createHitTester: createBarHitTester,
  components: { Path: PointCollection, Point: Bar }
});
BarSeries.defaultProps = {
  barWidth: 0.9
};
var _a$2;
var RawPath = function(_super) {
  __extends(RawPath2, _super);
  function RawPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawPath2.prototype.render = function() {
    var _a3 = this.props, path2 = _a3.path, animation = _a3.animation, coordinates = _a3.coordinates, rotated = _a3.rotated, index = _a3.index, state = _a3.state, pointComponent = _a3.pointComponent, color = _a3.color, clipPathId = _a3.clipPathId, scales = _a3.scales, pane = _a3.pane, restProps = __rest2(_a3, ["path", "animation", "coordinates", "rotated", "index", "state", "pointComponent", "color", "clipPathId", "scales", "pane"]);
    return (0, import_react.createElement)("path", __assign2({ clipPath: "url(#".concat(clipPathId, ")"), d: path2(coordinates), fill: "none", strokeWidth: 2, stroke: color }, restProps));
  };
  return RawPath2;
}(import_react.PureComponent);
var Path2 = withAnimation(processLineAnimation, function(_a3) {
  var coordinates = _a3.coordinates;
  return { coordinates };
}, getPathStart, isCoordinatesChanged)(withStates((_a$2 = {}, _a$2[HOVERED] = function(props) {
  return __assign2({ strokeWidth: 4 }, props);
}, _a$2[SELECTED] = function(props) {
  return __assign2({ strokeWidth: 4 }, props);
}, _a$2))(RawPath));
var Line = function(_super) {
  __extends(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.render = function() {
    var _a3 = this.props, rotated = _a3.rotated, path2 = _a3.path;
    var dPath = path2 === void 0 ? rotated ? dRotateLine : dLine : path2;
    return (0, import_react.createElement)(Path2, __assign2({}, this.props, { path: dPath }));
  };
  return Line2;
}(import_react.PureComponent);
var LineSeries = declareSeries("LineSeries", {
  getPointTransformer: getLinePointTransformer,
  createHitTester: createLineHitTester,
  components: { Path: Line }
});
var _a$3;
var RawSlice = function(_super) {
  __extends(RawSlice2, _super);
  function RawSlice2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawSlice2.prototype.render = function() {
    var _a3 = this.props, arg = _a3.arg, val = _a3.val, rotated = _a3.rotated, argument = _a3.argument, value = _a3.value, seriesIndex = _a3.seriesIndex, index = _a3.index, state = _a3.state, maxRadius = _a3.maxRadius, innerRadius = _a3.innerRadius, outerRadius = _a3.outerRadius, startAngle = _a3.startAngle, endAngle = _a3.endAngle, color = _a3.color, animation = _a3.animation, pane = _a3.pane, scales = _a3.scales, restProps = __rest2(_a3, ["arg", "val", "rotated", "argument", "value", "seriesIndex", "index", "state", "maxRadius", "innerRadius", "outerRadius", "startAngle", "endAngle", "color", "animation", "pane", "scales"]);
    return (0, import_react.createElement)(
      "g",
      { transform: "translate(".concat(arg, " ").concat(val, ")") },
      (0, import_react.createElement)("path", __assign2({ d: dPie(maxRadius, innerRadius, outerRadius, startAngle, endAngle), fill: color, stroke: "none" }, restProps))
    );
  };
  return RawSlice2;
}(import_react.PureComponent);
var Slice = withAnimation(processPieAnimation, function(_a3) {
  var innerRadius = _a3.innerRadius, outerRadius = _a3.outerRadius, startAngle = _a3.startAngle, endAngle = _a3.endAngle;
  return { innerRadius, outerRadius, startAngle, endAngle };
}, getPieStart, isValuesChanged, getDelay)(withStates((_a$3 = {}, _a$3[HOVERED] = withPattern(function(_a3) {
  var seriesIndex = _a3.seriesIndex, index = _a3.index, color = _a3.color;
  return "series-".concat(seriesIndex, "-point-").concat(index, "-color-").concat(color, "-hover");
}, { opacity: 0.75 })(RawSlice), _a$3[SELECTED] = withPattern(function(_a3) {
  var seriesIndex = _a3.seriesIndex, index = _a3.index, color = _a3.color;
  return "series-".concat(seriesIndex, "-point-").concat(index, "-color-").concat(color, "-selection");
}, { opacity: 0.5 })(RawSlice), _a$3))(RawSlice));
var PieSeries = declareSeries("PieSeries", {
  getPointTransformer: getPiePointTransformer,
  createHitTester: createPieHitTester,
  components: { Path: PointCollection, Point: Slice }
});
PieSeries.defaultProps = {
  innerRadius: 0,
  outerRadius: 1
};
var _a$4;
var RawPoint = function(_super) {
  __extends(RawPoint2, _super);
  function RawPoint2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RawPoint2.prototype.render = function() {
    var _a3 = this.props, arg = _a3.arg, val = _a3.val, rotated = _a3.rotated, animation = _a3.animation, argument = _a3.argument, value = _a3.value, seriesIndex = _a3.seriesIndex, index = _a3.index, state = _a3.state, pointOptions = _a3.point, color = _a3.color, pane = _a3.pane, scales = _a3.scales, restProps = __rest2(_a3, ["arg", "val", "rotated", "animation", "argument", "value", "seriesIndex", "index", "state", "point", "color", "pane", "scales"]);
    var x2 = rotated ? val : arg;
    var y2 = rotated ? arg : val;
    var visibility = getVisibility(pane, x2, y2, 0, 0);
    return (0, import_react.createElement)("path", __assign2({ transform: "translate(".concat(x2, " ").concat(y2, ")"), d: dSymbol(pointOptions), fill: color, visibility, stroke: "none" }, restProps));
  };
  return RawPoint2;
}(import_react.PureComponent);
var getAdjustedOptions = function(_a3) {
  var size = _a3.size;
  return { size: Math.round(size * 1.7) };
};
var Point = withAnimation(processPointAnimation, function(_a3) {
  var arg = _a3.arg, val = _a3.val;
  return { arg, val };
}, getPointStart, isValuesChanged)(withStates((_a$4 = {}, _a$4[HOVERED] = function(_a3) {
  var color = _a3.color, point5 = _a3.point, restProps = __rest2(_a3, ["color", "point"]);
  return __assign2({ stroke: color, strokeWidth: 4, fill: "none", point: getAdjustedOptions(point5) }, restProps);
}, _a$4[SELECTED] = function(_a3) {
  var color = _a3.color, point5 = _a3.point, restProps = __rest2(_a3, ["color", "point"]);
  return __assign2({ stroke: color, strokeWidth: 4, fill: "none", point: getAdjustedOptions(point5) }, restProps);
}, _a$4))(RawPoint));
var ScatterSeries = declareSeries("ScatterSeries", {
  getPointTransformer: getScatterPointTransformer,
  createHitTester: createScatterHitTester,
  components: { Path: PointCollection, Point }
});
ScatterSeries.defaultProps = {
  point: { size: 7 }
};
var Spline = function(_super) {
  __extends(Spline2, _super);
  function Spline2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Spline2.prototype.render = function() {
    var _a3 = this.props, rotated = _a3.rotated, path2 = _a3.path;
    var dPath = path2 === void 0 ? rotated ? dRotateSpline : dSpline : path2;
    return (0, import_react.createElement)(Path2, __assign2({}, this.props, { path: dPath }));
  };
  return Spline2;
}(import_react.PureComponent);
var SplineSeries = declareSeries("SplineSeries", {
  getPointTransformer: getLinePointTransformer,
  createHitTester: createSplineHitTester,
  components: { Path: Spline }
});
var getOffset2 = function(position) {
  return position >= 0 ? 0 : -position;
};
var getSize = function(position, delta) {
  return position >= 0 ? position + delta : -position;
};
var Root$1 = function(_super) {
  __extends(Root2, _super);
  function Root2(props) {
    var _this = _super.call(this, props) || this;
    _this.ref = (0, import_react.createRef)();
    _this.state = {
      x: 0,
      y: 0
    };
    _this.adjust = _this.adjust.bind(_this);
    return _this;
  }
  Root2.prototype.componentDidMount = function() {
    this.setState(this.adjust);
  };
  Root2.prototype.componentDidUpdate = function() {
    this.setState(this.adjust);
  };
  Root2.prototype.adjust = function(_, _a3) {
    var dx = _a3.dx, dy = _a3.dy, onSizeChange = _a3.onSizeChange;
    var bbox = this.ref.current.getBBox();
    var width = dx ? bbox.width : getSize(bbox.x, bbox.width);
    var height = dy ? bbox.height : getSize(bbox.y, bbox.height);
    var x2 = dx ? 0 : getOffset2(bbox.x);
    var y2 = dy ? 0 : getOffset2(bbox.y);
    onSizeChange({ width, height });
    return { x: x2, y: y2 };
  };
  Root2.prototype.render = function() {
    var _a3 = this.props, children = _a3.children, onSizeChange = _a3.onSizeChange, dx = _a3.dx, dy = _a3.dy, restProps = __rest2(_a3, ["children", "onSizeChange", "dx", "dy"]);
    var _b2 = this.state, x2 = _b2.x, y2 = _b2.y;
    return (0, import_react.createElement)("g", __assign2({ ref: this.ref, transform: "translate(".concat(x2, " ").concat(y2, ")") }, restProps), children);
  };
  return Root2;
}(import_react.PureComponent);
var Label$1 = function(_super) {
  __extends(Label2, _super);
  function Label2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Label2.prototype.render = function() {
    var _a3 = this.props, text = _a3.text, restProps = __rest2(_a3, ["text"]);
    return (0, import_react.createElement)("text", __assign2({}, restProps), text);
  };
  return Label2;
}(import_react.PureComponent);
var Line$1 = function(_super) {
  __extends(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.render = function() {
    var _a3 = this.props, x1 = _a3.x1, x2 = _a3.x2, y1 = _a3.y1, y2 = _a3.y2, restProps = __rest2(_a3, ["x1", "x2", "y1", "y2"]);
    return (0, import_react.createElement)("path", __assign2({ d: "M ".concat(x1, " ").concat(y1, " L ").concat(x2, " ").concat(y2) }, restProps));
  };
  return Line2;
}(import_react.PureComponent);
var SVG_STYLE$1 = {
  position: "absolute",
  left: 0,
  top: 0,
  overflow: "visible"
};
var RawAxis = function(_super) {
  __extends(RawAxis2, _super);
  function RawAxis2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.rootRef = (0, import_react.createRef)();
    _this.adjustedWidth = 0;
    _this.adjustedHeight = 0;
    return _this;
  }
  RawAxis2.prototype.renderAxis = function(position) {
    var _this = this;
    var _a3 = this.props, scaleName = _a3.scaleName, tickSize = _a3.tickSize, tickFormat = _a3.tickFormat, indentFromAxis = _a3.indentFromAxis, showTicks = _a3.showTicks, showLine = _a3.showLine, showLabels = _a3.showLabels, RootComponent = _a3.rootComponent, TickComponent = _a3.tickComponent, LabelComponent = _a3.labelComponent, LineComponent = _a3.lineComponent;
    var placeholder = "".concat(position, "-axis");
    var layoutName = "".concat(placeholder, "-").concat(scaleName);
    return (0, import_react.createElement)(
      Template,
      { name: placeholder },
      (0, import_react.createElement)(TemplatePlaceholder, null),
      (0, import_react.createElement)(TemplateConnector, null, function(_a4, _b2) {
        var scales = _a4.scales, layouts = _a4.layouts, rotated = _a4.rotated;
        var changeBBox = _b2.changeBBox;
        if (!isValidPosition(position, scaleName, rotated)) {
          return null;
        }
        var scale = scales[scaleName];
        if (!scale) {
          return null;
        }
        var _c = layouts[layoutName] || { width: 0, height: 0 }, width = _c.width, height = _c.height;
        var paneSize = layouts.pane;
        var _d = getTickCoordinates({
          callback: tickCoordinatesGetter,
          scaleName,
          position,
          tickSize,
          tickFormat,
          indentFromAxis,
          scale,
          paneSize: [paneSize.width, paneSize.height],
          rotated
        }), _e = __read2(_d.sides, 2), dx = _e[0], dy = _e[1], ticks = _d.ticks;
        var handleSizeChange = function(size) {
          var rect = _this.rootRef.current.getBoundingClientRect();
          var rectSize = [dx ? rect.width : size.width, dy ? rect.height : size.height];
          if (rectSize[0] === _this.adjustedWidth && rectSize[1] === _this.adjustedHeight) {
            return;
          }
          _this.adjustedWidth = rectSize[0];
          _this.adjustedHeight = rectSize[1];
          changeBBox({ placeholder: layoutName, bBox: size });
        };
        return (0, import_react.createElement)(
          "div",
          { style: {
            position: "relative",
            width: dy * width || void 0,
            height: dx * height || void 0,
            flexGrow: dx || void 0
          }, ref: _this.rootRef },
          (0, import_react.createElement)(
            "svg",
            { width: _this.adjustedWidth, height: _this.adjustedHeight, style: SVG_STYLE$1 },
            (0, import_react.createElement)(
              RootComponent,
              { dx, dy, onSizeChange: handleSizeChange },
              showTicks && ticks.map(function(_a5) {
                var x1 = _a5.x1, x2 = _a5.x2, y1 = _a5.y1, y2 = _a5.y2, key = _a5.key;
                return (0, import_react.createElement)(TickComponent, { key, x1, x2, y1, y2 });
              }),
              showLine && (0, import_react.createElement)(LineComponent, { x1: 0, x2: dx * paneSize.width, y1: 0, y2: dy * paneSize.height }),
              showLabels && ticks.map(function(_a5) {
                var text = _a5.text, xText = _a5.xText, yText = _a5.yText, delta = _a5.dy, textAnchor = _a5.textAnchor, key = _a5.key;
                return (0, import_react.createElement)(LabelComponent, { key, text, x: xText, y: yText, dy: delta, textAnchor });
              })
            )
          )
        );
      })
    );
  };
  RawAxis2.prototype.renderGrid = function() {
    var _a3 = this.props, scaleName = _a3.scaleName, showGrid = _a3.showGrid, GridComponent = _a3.gridComponent;
    return (0, import_react.createElement)(
      Template,
      { name: "series" },
      (0, import_react.createElement)(TemplatePlaceholder, null),
      (0, import_react.createElement)(TemplateConnector, null, function(_a4) {
        var scales = _a4.scales, layouts = _a4.layouts, rotated = _a4.rotated;
        var scale = scales[scaleName];
        if (!scale || !showGrid) {
          return null;
        }
        var _b2 = layouts.pane, width = _b2.width, height = _b2.height;
        var _c = getTickCoordinates({
          callback: gridCoordinatesGetter,
          scaleName,
          scale,
          paneSize: [width, height],
          rotated
        }), ticks = _c.ticks, _d = __read2(_c.sides, 2), dx = _d[0], dy = _d[1];
        return (0, import_react.createElement)(import_react.Fragment, null, ticks.map(function(_a5) {
          var key = _a5.key, x1 = _a5.x1, y1 = _a5.y1;
          return (0, import_react.createElement)(GridComponent, { key, x1, x2: x1 + dy * width, y1, y2: y1 + dx * height });
        }));
      })
    );
  };
  RawAxis2.prototype.render = function() {
    var position = this.props.position;
    var rotatedPosition = getRotatedPosition(position);
    return (0, import_react.createElement)(
      Plugin,
      { name: "Axis" },
      (0, import_react.createElement)(Getter, { name: "axesExist", value: true }),
      this.renderAxis(position),
      this.renderAxis(rotatedPosition),
      this.renderGrid()
    );
  };
  RawAxis2.components = {
    rootComponent: "Root",
    tickComponent: "Tick",
    labelComponent: "Label",
    lineComponent: "Line",
    gridComponent: "Grid"
  };
  RawAxis2.defaultProps = {
    tickSize: 5,
    indentFromAxis: 10
  };
  return RawAxis2;
}(import_react.PureComponent);
var Axis = withComponents({
  Label: Label$1,
  Line: Line$1,
  Root: Root$1,
  Tick: Line$1,
  Grid: Line$1
})(RawAxis);
var ArgumentAxis = withPatchedProps(function(props) {
  return __assign2(__assign2({ position: BOTTOM, showGrid: false, showTicks: true, showLine: true, showLabels: true }, props), { scaleName: ARGUMENT_DOMAIN });
})(Axis);
var ValueAxis = withPatchedProps(function(props) {
  return __assign2(__assign2({ position: LEFT, showGrid: true, showTicks: false, showLine: false, showLabels: true }, props), { scaleName: getValueDomainName(props.scaleName) });
})(Axis);
var dependencies = [{ name: "EventTracker", optional: true }];
var TooltipBase = function(_super) {
  __extends(TooltipBase2, _super);
  function TooltipBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      target: props.targetItem || props.defaultTargetItem
    };
    var handlePointerMove = _this.handlePointerMove.bind(_this);
    _this.getPointerMoveHandlers = function(_a3) {
      var _b2 = _a3.pointerMoveHandlers, pointerMoveHandlers = _b2 === void 0 ? [] : _b2;
      return __spreadArray2(__spreadArray2([], __read2(pointerMoveHandlers), false), [
        handlePointerMove
      ], false);
    };
    return _this;
  }
  TooltipBase2.getDerivedStateFromProps = function(props, state) {
    return { target: props.targetItem !== void 0 ? props.targetItem : state.target };
  };
  TooltipBase2.prototype.handlePointerMove = function(_a3) {
    var targets = _a3.targets;
    this.setState(function(_a4, _b2) {
      var currentTarget = _a4.target;
      var onTargetItemChange = _b2.onTargetItemChange;
      var target = processHandleTooltip(targets, currentTarget, onTargetItemChange);
      if (target === void 0) {
        return null;
      }
      return { target };
    });
  };
  TooltipBase2.prototype.render = function() {
    var _a3 = this.props, OverlayComponent = _a3.overlayComponent, ContentComponent = _a3.contentComponent, SheetComponent = _a3.sheetComponent, arrowComponent = _a3.arrowComponent;
    var target = this.state.target;
    return (0, import_react.createElement)(
      Plugin,
      { name: "Tooltip", dependencies },
      (0, import_react.createElement)(Getter, { name: "pointerMoveHandlers", computed: this.getPointerMoveHandlers }),
      (0, import_react.createElement)(
        Template,
        { name: "series" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(_a4) {
          var series2 = _a4.series, rootRef = _a4.rootRef, rotated = _a4.rotated;
          if (!target) {
            return null;
          }
          var _b2 = getParameters(series2, target), text = _b2.text, element = _b2.element;
          return (0, import_react.createElement)(
            OverlayComponent,
            { key: "".concat(target.series).concat(target.point), target: createReference(element, rootRef), rotated, arrowComponent },
            (0, import_react.createElement)(
              SheetComponent,
              null,
              (0, import_react.createElement)(ContentComponent, { text, targetItem: target })
            )
          );
        })
      )
    );
  };
  TooltipBase2.components = {
    overlayComponent: "Overlay",
    contentComponent: "Content",
    arrowComponent: "Arrow",
    sheetComponent: "Sheet"
  };
  return TooltipBase2;
}(import_react.PureComponent);
var Tooltip = TooltipBase;
var DragBox = function(_super) {
  __extends(DragBox2, _super);
  function DragBox2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DragBox2.prototype.render = function() {
    var _a3 = this.props, rect = _a3.rect, restProps = __rest2(_a3, ["rect"]);
    return (0, import_react.createElement)("rect", __assign2({ x: rect.x, y: rect.y, width: rect.width, height: rect.height }, restProps));
  };
  return DragBox2;
}(import_react.PureComponent);
var events = {
  wheel: { func: "onWheel" },
  mousedown: {
    func: "onStart",
    extraEvents: ["mousemove", "mouseup"]
  },
  touchstart: {
    func: "onStart",
    extraEvents: ["touchmove", "touchend"]
  }
};
var ZoomPanProvider = function(_super) {
  __extends(ZoomPanProvider2, _super);
  function ZoomPanProvider2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZoomPanProvider2.prototype.componentDidMount = function() {
    var _this = this;
    this.svgElement = this.props.rootRef.current;
    setCursorType(this.svgElement);
    this.windowHandlers = Object.keys(events).reduce(function(prev, key) {
      var _a3, _b2;
      var extraEvents = events[key].extraEvents;
      if (extraEvents) {
        return __assign2(__assign2({}, prev), (_a3 = {}, _a3[key] = (_b2 = {}, _b2[extraEvents[0]] = function(event) {
          _this.props.onMove(event);
        }, _b2[extraEvents[1]] = function(event) {
          _this.props.onEnd(event);
          setCursorType(_this.svgElement);
          detachEvents(window, _this.windowHandlers[key]);
        }, _b2), _a3));
      }
      return prev;
    }, {});
    this.handlers = Object.keys(events).reduce(function(prev, key) {
      var _a3;
      return __assign2(__assign2({}, prev), (_a3 = {}, _a3[key] = function(e) {
        _this.props[events[key].func](e);
        if (events[key].extraEvents) {
          attachEvents(window, _this.windowHandlers[key]);
        }
      }, _a3));
    }, {});
    attachEvents(this.svgElement, this.handlers);
  };
  ZoomPanProvider2.prototype.componentWillUnmount = function() {
    var _this = this;
    detachEvents(this.svgElement, this.handlers);
    Object.keys(this.windowHandlers).forEach(function(el) {
      detachEvents(window, _this.windowHandlers[el]);
    });
  };
  ZoomPanProvider2.prototype.render = function() {
    return null;
  };
  return ZoomPanProvider2;
}(import_react.PureComponent);
var ZoomAndPanBase = function(_super) {
  __extends(ZoomAndPanBase2, _super);
  function ZoomAndPanBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.multiTouchDelta = null;
    _this.lastCoordinates = null;
    _this.rectOrigin = null;
    _this.offset = [0, 0];
    _this.state = {
      viewport: props.viewport || props.defaultViewport,
      rectBox: null
    };
    return _this;
  }
  ZoomAndPanBase2.getDerivedStateFromProps = function(props, state) {
    return {
      viewport: props.viewport !== void 0 ? props.viewport : state.viewport
    };
  };
  ZoomAndPanBase2.prototype.handleStart = function(zoomRegionKey, e) {
    e.preventDefault();
    this.offset = getOffset(e.currentTarget);
    var coords = getEventCoords(e, this.offset);
    if (isKeyPressed(e, zoomRegionKey)) {
      this.rectOrigin = coords;
    } else {
      setCursorType(e.currentTarget, "grabbing");
    }
    if (isMultiTouch(e)) {
      this.multiTouchDelta = getDeltaForTouches(e.touches).delta;
    }
    this.lastCoordinates = coords;
  };
  ZoomAndPanBase2.prototype.handleMove = function(scales, rotated, e, pane) {
    e.preventDefault();
    clear();
    if (isMultiTouch(e)) {
      var current = getDeltaForTouches(e.touches);
      this.zoom(scales, rotated, current.delta - this.multiTouchDelta, current.center);
      this.multiTouchDelta = current.delta;
    } else {
      this.scroll(scales, rotated, e, pane);
    }
  };
  ZoomAndPanBase2.prototype.scroll = function(scales, rotated, e, pane) {
    var _this = this;
    var coords = getEventCoords(e, this.offset);
    var deltaX = coords[0] - this.lastCoordinates[0];
    var deltaY = coords[1] - this.lastCoordinates[1];
    this.lastCoordinates = coords;
    this.setState(function(_a3, _b2) {
      var viewport = _a3.viewport;
      var onViewportChange = _b2.onViewportChange, interactionWithArguments = _b2.interactionWithArguments, interactionWithValues = _b2.interactionWithValues;
      if (_this.rectOrigin) {
        return {
          rectBox: getRect$1(rotated, interactionWithArguments, interactionWithValues, _this.rectOrigin, coords, pane)
        };
      }
      return getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], "pan", [-deltaX, -deltaY], null, null, viewport, onViewportChange);
    });
  };
  ZoomAndPanBase2.prototype.handleEnd = function(scales, rotated) {
    var _this = this;
    this.lastCoordinates = null;
    this.multiTouchDelta = null;
    if (this.rectOrigin) {
      this.setState(function(_a3, _b2) {
        var viewport = _a3.viewport, rectBox = _a3.rectBox;
        var onViewportChange = _b2.onViewportChange, interactionWithArguments = _b2.interactionWithArguments, interactionWithValues = _b2.interactionWithValues;
        if (rectBox === null)
          return {};
        _this.rectOrigin = null;
        return __assign2({ rectBox: null }, getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], "zoom", null, null, [
          [rectBox.x, rectBox.x + rectBox.width],
          [rectBox.y, rectBox.y + rectBox.height]
        ], viewport, onViewportChange));
      });
    }
  };
  ZoomAndPanBase2.prototype.zoom = function(scales, rotated, delta, anchors) {
    this.setState(function(_a3, _b2) {
      var viewport = _a3.viewport;
      var onViewportChange = _b2.onViewportChange, interactionWithArguments = _b2.interactionWithArguments, interactionWithValues = _b2.interactionWithValues;
      return getViewport(scales, rotated, [interactionWithArguments, interactionWithValues], "zoom", [delta, delta], anchors, null, viewport, onViewportChange);
    });
  };
  ZoomAndPanBase2.prototype.handleZoom = function(scales, rotated, e) {
    e.preventDefault();
    var center = getEventCoords(e, getOffset(e.currentTarget));
    this.zoom(scales, rotated, getWheelDelta(e), center);
  };
  ZoomAndPanBase2.prototype.render = function() {
    var _this = this;
    var _a3 = this.state, viewport = _a3.viewport, rectBox = _a3.rectBox;
    var _b2 = this.props, DragBoxComponent = _b2.dragBoxComponent, zoomRegionKey = _b2.zoomRegionKey;
    var getAdjustedLayout = function(_a4) {
      var domains = _a4.domains, ranges = _a4.ranges;
      return adjustLayout(domains, ranges, viewport);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "zoomAndPan" },
      (0, import_react.createElement)(Getter, { name: "ranges", computed: getAdjustedLayout }),
      (0, import_react.createElement)(
        Template,
        { name: "root" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(_a4) {
          var scales = _a4.scales, rotated = _a4.rotated, rootRef = _a4.rootRef, layouts = _a4.layouts;
          return (0, import_react.createElement)(ZoomPanProvider, { rootRef, onWheel: function(e) {
            return _this.handleZoom(scales, rotated, e);
          }, onStart: function(e) {
            return _this.handleStart(zoomRegionKey, e);
          }, onMove: function(e) {
            return _this.handleMove(scales, rotated, e, layouts.pane);
          }, onEnd: function(e) {
            return _this.handleEnd(scales, rotated);
          } });
        })
      ),
      (0, import_react.createElement)(
        Template,
        { name: "series" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        rectBox ? (0, import_react.createElement)(DragBoxComponent, { rect: rectBox }) : null
      )
    );
  };
  ZoomAndPanBase2.components = {
    dragBoxComponent: "DragBox"
  };
  ZoomAndPanBase2.defaultProps = {
    interactionWithValues: "none",
    interactionWithArguments: "both",
    zoomRegionKey: "shift"
  };
  return ZoomAndPanBase2;
}(import_react.PureComponent);
var ZoomAndPan = withComponents({ DragBox })(ZoomAndPanBase);
var wrapToList = function(arg) {
  return arg ? [arg] : [];
};
var EVENT_NAME_TO_REACT_MAP = {
  click: "onClick",
  mousemove: "onMouseMove",
  mouseleave: "onMouseLeave",
  touchstart: "onTouchStart"
};
var translateEventNames = function(handlers) {
  var result = {};
  Object.entries(handlers).forEach(function(_a3) {
    var _b2 = __read2(_a3, 2), name = _b2[0], handler = _b2[1];
    result[EVENT_NAME_TO_REACT_MAP[name]] = handler;
  });
  return result;
};
var EventTrackerBase = function(_super) {
  __extends(EventTrackerBase2, _super);
  function EventTrackerBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  EventTrackerBase2.prototype.render = function() {
    var _a3 = this.props, onClick = _a3.onClick, onPointerMove = _a3.onPointerMove;
    return (0, import_react.createElement)(
      Plugin,
      { name: "EventTracker" },
      (0, import_react.createElement)(Getter, { name: "clickHandlers", value: wrapToList(onClick) }),
      (0, import_react.createElement)(Getter, { name: "pointerMoveHandlers", value: wrapToList(onPointerMove) }),
      (0, import_react.createElement)(Template, { name: "canvas" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a4) {
          var series2 = _a4.series, clickHandlers = _a4.clickHandlers, pointerMoveHandlers = _a4.pointerMoveHandlers;
          var handlers = buildEventHandlers(series2, { clickHandlers, pointerMoveHandlers });
          return (0, import_react.createElement)(TemplatePlaceholder, { params: __assign2(__assign2({}, params), translateEventNames(handlers)) });
        });
      })
    );
  };
  return EventTrackerBase2;
}(import_react.PureComponent);
var EventTracker = EventTrackerBase;
var dependencies$1 = [{ name: "EventTracker", optional: true }];
var HoverStateBase = function(_super) {
  __extends(HoverStateBase2, _super);
  function HoverStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      hover: props.hover || props.defaultHover
    };
    var handlePointerMove = _this.handlePointerMove.bind(_this);
    _this.getPointerMoveHandlers = function(_a3) {
      var _b2 = _a3.pointerMoveHandlers, pointerMoveHandlers = _b2 === void 0 ? [] : _b2;
      return __spreadArray2(__spreadArray2([], __read2(pointerMoveHandlers), false), [
        handlePointerMove
      ], false);
    };
    return _this;
  }
  HoverStateBase2.getDerivedStateFromProps = function(props, state) {
    return { hover: props.hover !== void 0 ? props.hover : state.hover };
  };
  HoverStateBase2.prototype.handlePointerMove = function(_a3) {
    var targets = _a3.targets;
    this.setState(function(_a4, _b2) {
      var currentTarget = _a4.hover;
      var onHoverChange = _b2.onHoverChange;
      var hover = processPointerMove(targets, currentTarget, onHoverChange);
      return hover !== void 0 ? { hover } : null;
    });
  };
  HoverStateBase2.prototype.render = function() {
    var hover = this.state.hover;
    var targets = hover ? [hover] : [];
    var getSeries2 = function(_a3) {
      var series2 = _a3.series;
      return changeSeriesState(series2, targets, HOVERED);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "HoverState", dependencies: dependencies$1 },
      (0, import_react.createElement)(Getter, { name: "pointerMoveHandlers", computed: this.getPointerMoveHandlers }),
      (0, import_react.createElement)(Getter, { name: "series", computed: getSeries2 })
    );
  };
  return HoverStateBase2;
}(import_react.PureComponent);
var HoverState = HoverStateBase;
var SelectionStateBase = function(_super) {
  __extends(SelectionStateBase2, _super);
  function SelectionStateBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SelectionStateBase2.prototype.render = function() {
    var selection = this.props.selection;
    var targets = selection || [];
    var getSeries2 = function(_a3) {
      var series2 = _a3.series;
      return changeSeriesState(series2, targets, SELECTED);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "SelectionState" },
      (0, import_react.createElement)(Getter, { name: "series", computed: getSeries2 })
    );
  };
  return SelectionStateBase2;
}(import_react.PureComponent);
var SelectionState = SelectionStateBase;

export {
  TOP,
  RIGHT,
  Palette,
  Chart,
  Legend,
  Title,
  withPatchedProps,
  Scale,
  ArgumentScale,
  ValueScale,
  Stack,
  Animation,
  AreaSeries,
  BarSeries,
  LineSeries,
  PieSeries,
  ScatterSeries,
  SplineSeries,
  Axis,
  ArgumentAxis,
  ValueAxis,
  Tooltip,
  ZoomAndPan,
  EventTracker,
  HoverState,
  SelectionState
};
/*! Bundled license information:

@devexpress/dx-chart-core/dist/dx-chart-core.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@devexpress/dx-react-chart/dist/dx-react-chart.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-K2R3VCOC.js.map
